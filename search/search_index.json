{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Padr\u00f5es de C\u00f3digo Objetivo deste Guia Este guia apresenta as regras e padr\u00f5es de codifica\u00e7\u00e3o a serem seguidos pelas equipes da BuildBox , que desenvolvem software usando as seguintes tecnologias: React.js React-Native TypeScript JavaScript Node.js Nest.js Estes padr\u00f5es t\u00eam dois objetivos principais: Facilitar o desenvolvimento inicial e manuten\u00e7\u00e3o de c\u00f3digo, reduzindo o tempo e custos Garantir o uso de boas pr\u00e1ticas de forma a melhorar a qualidade Os padr\u00f5es est\u00e3o organizados em 2 grandes se\u00e7\u00f5es, Clean Code e Design Patterns , conforme apresentado no \u00edndice, abaixo. A se\u00e7\u00e3o Clean Code trata de padr\u00f5es que tornam o c\u00f3digo mais leg\u00edvel, autoexplicativo e, assim, f\u00e1cil de entender e de manter. Na se\u00e7\u00e3o Design Patterns s\u00e3o apresentados os principais padr\u00f5es de c\u00f3digo usados na BuildBox (equipe JS) que representam decis\u00f5es de arquitetura que visam aumentar, al\u00e9m da clareza do c\u00f3digo, tamb\u00e9m a reusabilidade e facilidade de evolu\u00e7\u00e3o dos sistemas. \u00cdndice de Conte\u00fado 1- Clean Code (Legibilidade) 1.1- Nomenclatura 1.1.1- Usar as seguintes nota\u00e7\u00f5es de caixa 1.1.2- Usar nomes descritivos e com significado Vari\u00e1veis, propriedades e argumentos de fun\u00e7\u00f5es Fun\u00e7\u00f5es e m\u00e9todos Componentes 1.1.3- Usar nomes espec\u00edficos, evitando nomes amb\u00edguos no escopo 1.1.4- Ser consistente no escopo do projeto 1.1.5- Usar aspas simples 1.2- Formata\u00e7\u00e3o do c\u00f3digo 1.2.1- Evitar coment\u00e1rios 1.2.2- Formata\u00e7\u00e3o horizontal 1.2.3- Formata\u00e7\u00e3o vertical 1.3- Controle do fluxo 1.3.1- Preferir cl\u00e1usulas condicionais afirmativas, ao inv\u00e9s de negativas 1.3.2- Usar o m\u00ednimo aninhamento poss\u00edvel Usar cl\u00e1usulas condicionais de 'Prote\u00e7\u00e3o' Refatorar estruturas de controle em fun\u00e7\u00f5es separadas 1.3.3- Substituir declara\u00e7\u00f5es switch/if por literais de objetos 1.3.4- Usar Exceptions para tratar erros 1.4- Fun\u00e7\u00f5es e m\u00e9todos 1.4.1- DRY ( D on't R epeat Y ourselt) 1.4.2- As fun\u00e7\u00f5es devem fazer apenas uma coisa (Single Responsability Principle) 1.4.3- Limitar o n\u00famero de argumentos das fun\u00e7\u00f5es 1.4.4- Usar par\u00e2metros default 1.4.5- Evitar efeitos colaterais das fun\u00e7\u00f5es 1.5- Configura\u00e7\u00e3o VSCode 2- Design Patterns (Padr\u00f5es de Design) 2.1- Programa - Estrutura de pastas do projeto 2.2- Programa - Configura\u00e7\u00e3o de estilos 2.3- Programa - Roteamento de p\u00e1ginas 2.4- Programa - Menu(s) de navega\u00e7\u00e3o 2.5- Programa - Processamento Ass\u00edncrono 2.6- Programa - Acesso a APIs 2.7- Programa - Tratamento de erros 2.8- Programa - Gerenciamento de State 2.9- Programa - Autentica\u00e7\u00e3o 2.10- Componentes - Coes\u00e3o e Reuso 2.11- Componentes - Princ\u00edpios SOLID 2.12- Componentes - Controller/View 2.13- Componentes - Formul\u00e1rios 2.14- Componentes - Hooks Hist\u00f3rico de Revis\u00f5es Vers\u00e3o Data Descri\u00e7\u00e3o 01-D02 06-Jun-2023 Atualiza\u00e7\u00e3o do \u00cdndice 01-D01 05-Jun-2023 Rascunho para primeira revis\u00e3o t\u00e9cnica - - -","title":"Padr\u00f5es de C\u00f3digo<br>"},{"location":"#padroes-de-codigo","text":"","title":"Padr\u00f5es de C\u00f3digo"},{"location":"#objetivo-deste-guia","text":"Este guia apresenta as regras e padr\u00f5es de codifica\u00e7\u00e3o a serem seguidos pelas equipes da BuildBox , que desenvolvem software usando as seguintes tecnologias: React.js React-Native TypeScript JavaScript Node.js Nest.js Estes padr\u00f5es t\u00eam dois objetivos principais: Facilitar o desenvolvimento inicial e manuten\u00e7\u00e3o de c\u00f3digo, reduzindo o tempo e custos Garantir o uso de boas pr\u00e1ticas de forma a melhorar a qualidade Os padr\u00f5es est\u00e3o organizados em 2 grandes se\u00e7\u00f5es, Clean Code e Design Patterns , conforme apresentado no \u00edndice, abaixo. A se\u00e7\u00e3o Clean Code trata de padr\u00f5es que tornam o c\u00f3digo mais leg\u00edvel, autoexplicativo e, assim, f\u00e1cil de entender e de manter. Na se\u00e7\u00e3o Design Patterns s\u00e3o apresentados os principais padr\u00f5es de c\u00f3digo usados na BuildBox (equipe JS) que representam decis\u00f5es de arquitetura que visam aumentar, al\u00e9m da clareza do c\u00f3digo, tamb\u00e9m a reusabilidade e facilidade de evolu\u00e7\u00e3o dos sistemas.","title":"Objetivo deste Guia"},{"location":"#indice-de-conteudo","text":"1- Clean Code (Legibilidade) 1.1- Nomenclatura 1.1.1- Usar as seguintes nota\u00e7\u00f5es de caixa 1.1.2- Usar nomes descritivos e com significado Vari\u00e1veis, propriedades e argumentos de fun\u00e7\u00f5es Fun\u00e7\u00f5es e m\u00e9todos Componentes 1.1.3- Usar nomes espec\u00edficos, evitando nomes amb\u00edguos no escopo 1.1.4- Ser consistente no escopo do projeto 1.1.5- Usar aspas simples 1.2- Formata\u00e7\u00e3o do c\u00f3digo 1.2.1- Evitar coment\u00e1rios 1.2.2- Formata\u00e7\u00e3o horizontal 1.2.3- Formata\u00e7\u00e3o vertical 1.3- Controle do fluxo 1.3.1- Preferir cl\u00e1usulas condicionais afirmativas, ao inv\u00e9s de negativas 1.3.2- Usar o m\u00ednimo aninhamento poss\u00edvel Usar cl\u00e1usulas condicionais de 'Prote\u00e7\u00e3o' Refatorar estruturas de controle em fun\u00e7\u00f5es separadas 1.3.3- Substituir declara\u00e7\u00f5es switch/if por literais de objetos 1.3.4- Usar Exceptions para tratar erros 1.4- Fun\u00e7\u00f5es e m\u00e9todos 1.4.1- DRY ( D on't R epeat Y ourselt) 1.4.2- As fun\u00e7\u00f5es devem fazer apenas uma coisa (Single Responsability Principle) 1.4.3- Limitar o n\u00famero de argumentos das fun\u00e7\u00f5es 1.4.4- Usar par\u00e2metros default 1.4.5- Evitar efeitos colaterais das fun\u00e7\u00f5es 1.5- Configura\u00e7\u00e3o VSCode 2- Design Patterns (Padr\u00f5es de Design) 2.1- Programa - Estrutura de pastas do projeto 2.2- Programa - Configura\u00e7\u00e3o de estilos 2.3- Programa - Roteamento de p\u00e1ginas 2.4- Programa - Menu(s) de navega\u00e7\u00e3o 2.5- Programa - Processamento Ass\u00edncrono 2.6- Programa - Acesso a APIs 2.7- Programa - Tratamento de erros 2.8- Programa - Gerenciamento de State 2.9- Programa - Autentica\u00e7\u00e3o 2.10- Componentes - Coes\u00e3o e Reuso 2.11- Componentes - Princ\u00edpios SOLID 2.12- Componentes - Controller/View 2.13- Componentes - Formul\u00e1rios 2.14- Componentes - Hooks","title":"\u00cdndice de Conte\u00fado"},{"location":"#historico-de-revisoes","text":"Vers\u00e3o Data Descri\u00e7\u00e3o 01-D02 06-Jun-2023 Atualiza\u00e7\u00e3o do \u00cdndice 01-D01 05-Jun-2023 Rascunho para primeira revis\u00e3o t\u00e9cnica - - -","title":"Hist\u00f3rico de Revis\u00f5es"},{"location":"1-Clean-Code/1-nomenclature/","text":"1.1- Nomenclatura 1.1.1- Usar as seguintes nota\u00e7\u00f5es de caixa Nomes de vari\u00e1veis, propriedades, fun\u00e7\u00f5es, argumentos de fun\u00e7\u00f5es: Usar camelCase Nomes de Componentes React, Classes: Usar PascalCase Nomes de interfaces (TypeScript): Iniciar com 'I' mai\u00fasculo, por ex: IUser Nomes de ENUMS: Iniciar com 'E' mai\u00fasculo, por ex: EUserStatus 1.1.2- Usar nomes descritivos e com significado Usar nomes que descrevem claramente e de forma distinta o conte\u00fado da vari\u00e1vel, a identidade do componente React ou a finalidade da fun\u00e7\u00e3o ou m\u00e9todo, sem usar abrevia\u00e7\u00f5es que obrigariam o leitor a procurar o significado; expl\u00edcito \u00e9 melhor do que impl\u00edcito. Por exemplo: // Bad \ud83d\ude15 locations.forEach(l => { // Several lines of code, here // ... dispatch(l) // Trying to remenber what `l` means... }) // Good \ud83d\ude00 locations.forEach(location => { // Several lines of code, here // ... dispatch(location) // No waste of time to remember }) Especificamente, para nomes de vari\u00e1veis, propriedades e argumentos de fun\u00e7\u00f5es: Usar substantivos, simples ou compostos // Good \ud83d\ude00 const colors = ['blue', 'green', 'yellow'] // Substantivo simples const color = { name: 'blue', hex: '#800080' } // Subatantivo simples const numberOfColors = 5 // Substantivo composto const numberOfSelectedColors = 2 // Substantivo composto Ou, usar um adjetivo seguido por um substantivo // Good \ud83d\ude00 const targetColor = 'purple' const reservedBook = { title: 'The Sun Also Rises', author: 'Ernest Hemingway' } No caso de vari\u00e1veis boolean , usar perguntas // Good \ud83d\ude00 const isLogged = true const isColorSelected = false const isColorValida = true Nomes ruins // Bad \ud83d\ude15 const TargetColor = \"purple\" const fnd = true const list = [\"blue\", \"green\", \"yellow\"] const obj = { color: \"blue\", hex: \"#800080\" } const num = 5 if (exist) { // ... } Nos nomes de fun\u00e7\u00f5es e m\u00e9todos: Usar o verbo que descreve o prop\u00f3sito da fun\u00e7\u00e3o + um objeto direto ou indireto // Good \ud83d\ude00 function parseItemPrice({ price }:{ price: string }) {...} // Aqui: // parse \u00e9 o verbo // ItemPrice \u00e9 o objeto direto function getRelativeShippingInfo() {...} // Aqui: // get \u00e9 o verbo // RelativeShippingInfo \u00e9 o objeto direto function extractUserDataFromTable({ userId }:{ userId: string }) {...} // Aqui: // extract \u00e9 o verbo // UserData \u00e9 o objeto direto // From \u00e9 uma preposi\u00e7\u00e3o auxiliar. Importante neste caso, pois, sem ela, // pareceria que o objeto direto \u00e9 UserDataTable // Table \u00e9 o objeto indireto // Outros bons exemplos: function calculateTotalCost() {...} function getDeliveryDate() {...} function saveUserData() {...} function validateForm() {...} function displayErrorMessage() {...} function deleteElement() {...} function fetchAiAPI() {...} Com TypeScript, alguns casos simples permitem o uso apenas do objeto direto, sem o verbo // Good \ud83d\ude00 function toNumber({ price }:{ price: string }) {...} // uma contra\u00e7\u00e3o de convertStringToNumber() Nomes ruins para fun\u00e7\u00f5es ou m\u00e9todos // Bad \ud83d\ude15 function deliveryDate() {...} // Falta o verbo. Delivery aqui significa entrega, um substantivo function func1() {...} // N\u00e3o diz nada function test() {...} // Testa o qu\u00ea? function fetch() {...} // Faz um fetch em qu\u00ea? function process() {...} // N\u00e3o diz nada function run() {...} // Executa o qu\u00ea? Nos nomes de fun\u00e7\u00f5es e propriedades, herdados de bibliotecas: Nestes casos, como por exemplo uma fun\u00e7\u00e3o chamada fetch ou uma property chamada isLoading, , quando poss\u00edvel, sobrescrever tais nomes gen\u00e9ricos com nomes mais espec\u00edficos, no contexto do seu aplicativo, como por exemplo, isClientLoading ou fetchClientAccountData . Nomes de componentes React: Os nomes dos componentes, ou objetos importados de bibliotecas, devem usar a conven\u00e7\u00e3o PascalCase , ou seja, todas as palavras iniciam com letra mai\u00fascula. Al\u00e9m disso, embora usemos componentes React funcionais, (que s\u00e3o fun\u00e7\u00f5es JavaScript, ao inv\u00e9s de classes), devemos usar substantivos ou substantivos compostos, sem uso do verbo, como no caso das vari\u00e1veis, pois os componentes representam principalmente coisas (embora contenham fun\u00e7\u00f5es). // Good \ud83d\ude00 function Buttom(...) {...} function RadioButton(...) {...} function MultilinesTextField(...) {...} function CancelOrderModal(...) {...} // A palavra 'Cancel', aqui, n\u00e3o est\u00e1 sendo usada como um // verbo (Cancelar) e, sim, como um adjetivo (Cancelamento) function SellerDetails(...) {...} function AdminProducts(...) {...} // Pode referir-se a uma lista function SellerCreation(...) {...} function SellerEdition(...) {...} function EmailActivation(...) {...} function Products(...) {...} // Bad \ud83d\ude15 function AdminProductsList(...) {...} // N\u00e3o usar a palavra List function CreateSeller(...) {...} // N\u00e3o deveria usar verbo function EditSeller(...) {...} // N\u00e3o deveria usar verbo function ListProducts(...) {...} // 'List' \u00e9 um verbo aqui e n\u00e3o deveria ser usado 1.1.3- Usar nomes espec\u00edficos, evitando nomes amb\u00edguos no escopo Ser espec\u00edfico o suficiente para identificar o que est\u00e1 sendo referenciado de forma un\u00edvoca, no escopo, e preferencialmente, no projeto. Por exemplo, se o escopo \u00e9 uma fun\u00e7\u00e3o de um componente, e \u00e9 necess\u00e1rio salvar um array de 'Pedidos' (Orders) de um certo 'Vendedor' (Seller), podemos usar uma vari\u00e1vel chamada 'orders' para salvar o array , mesmo que sejam pedidos de um vendedor espec\u00edfico. Entretanto se o escopo desta vari\u00e1vel for o componente e for necess\u00e1rio criar um state para salvar o array de 'Pedidos', ainda de um vendedor espec\u00edfico, um nome melhor para este state seria sellerOrders, uma vez que apenas 'orders' subentende que o array salva todos os pedidos de todos os vendedores. Se a fun\u00e7\u00e3o for 'clean' e, portanto, pequena, esta ambiguidade n\u00e3o ocorrer\u00e1, pois ser\u00e1 evidente que 'orders' se refere a pedidos de um vendedor espec\u00edfico. J\u00e1 em um componente, onde o c\u00f3digo \u00e9 bem mais longo do que em uma fun\u00e7\u00e3o, essa ambiguidade n\u00e3o ser\u00e1 percebida com facilidade, deixando o c\u00f3digo mais obscuro e, por isso, a necessidade de nomear o 'state' de forma mais espec\u00edfica. De modo geral, quanto mais amplo o escopo, mais espec\u00edfico deve ser o nome, para impedir conflitos de entendimento. Assim, se estivermos nomeando uma fun\u00e7\u00e3o ou componente 'extern' que pode ser acessado por todo o programa, devemos tornar o nome espec\u00edfico o suficiente para que n\u00e3o possa ser confundido com algo semelhante no resto do sistema. 1.1.4- Ser consistente no escopo do projeto Deve-se procurar usar os mesmos nomes e verbos para os mesmos tipos de conte\u00fado e/ou a\u00e7\u00f5es, dentro do projeto corrente e, se poss\u00edvel, entre todos os projetos da BuildBox. Por exemplo: // Bad \ud83d\ude15 getUserInfo() getClientData() getCustomerRecord() // Good \ud83d\ude00 getClient() 1.1.5- Usar aspas simples Usar aspas simples (' ') nos literais de strings e nomes de propriedades, ao inv\u00e9s de aspas duplas (\" \"). 1.1.6- N\u00e3o usar export default Nunca usar export default para exportar um componente React, de modo a obrigar o uso do nome espec\u00edfico na importa\u00e7\u00e3o.","title":"1.1- Nomenclatura"},{"location":"1-Clean-Code/1-nomenclature/#11-nomenclatura","text":"","title":"1.1- Nomenclatura"},{"location":"1-Clean-Code/1-nomenclature/#111-usar-as-seguintes-notacoes-de-caixa","text":"Nomes de vari\u00e1veis, propriedades, fun\u00e7\u00f5es, argumentos de fun\u00e7\u00f5es: Usar camelCase Nomes de Componentes React, Classes: Usar PascalCase Nomes de interfaces (TypeScript): Iniciar com 'I' mai\u00fasculo, por ex: IUser Nomes de ENUMS: Iniciar com 'E' mai\u00fasculo, por ex: EUserStatus","title":"1.1.1- Usar as seguintes nota\u00e7\u00f5es de caixa"},{"location":"1-Clean-Code/1-nomenclature/#112-usar-nomes-descritivos-e-com-significado","text":"Usar nomes que descrevem claramente e de forma distinta o conte\u00fado da vari\u00e1vel, a identidade do componente React ou a finalidade da fun\u00e7\u00e3o ou m\u00e9todo, sem usar abrevia\u00e7\u00f5es que obrigariam o leitor a procurar o significado; expl\u00edcito \u00e9 melhor do que impl\u00edcito. Por exemplo: // Bad \ud83d\ude15 locations.forEach(l => { // Several lines of code, here // ... dispatch(l) // Trying to remenber what `l` means... }) // Good \ud83d\ude00 locations.forEach(location => { // Several lines of code, here // ... dispatch(location) // No waste of time to remember })","title":"1.1.2- Usar nomes descritivos e com significado"},{"location":"1-Clean-Code/1-nomenclature/#especificamente-para-nomes-de-variaveis-propriedades-e-argumentos-de-funcoes","text":"Usar substantivos, simples ou compostos // Good \ud83d\ude00 const colors = ['blue', 'green', 'yellow'] // Substantivo simples const color = { name: 'blue', hex: '#800080' } // Subatantivo simples const numberOfColors = 5 // Substantivo composto const numberOfSelectedColors = 2 // Substantivo composto Ou, usar um adjetivo seguido por um substantivo // Good \ud83d\ude00 const targetColor = 'purple' const reservedBook = { title: 'The Sun Also Rises', author: 'Ernest Hemingway' } No caso de vari\u00e1veis boolean , usar perguntas // Good \ud83d\ude00 const isLogged = true const isColorSelected = false const isColorValida = true Nomes ruins // Bad \ud83d\ude15 const TargetColor = \"purple\" const fnd = true const list = [\"blue\", \"green\", \"yellow\"] const obj = { color: \"blue\", hex: \"#800080\" } const num = 5 if (exist) { // ... }","title":"Especificamente, para nomes de vari\u00e1veis, propriedades e argumentos de fun\u00e7\u00f5es:"},{"location":"1-Clean-Code/1-nomenclature/#nos-nomes-de-funcoes-e-metodos","text":"Usar o verbo que descreve o prop\u00f3sito da fun\u00e7\u00e3o + um objeto direto ou indireto // Good \ud83d\ude00 function parseItemPrice({ price }:{ price: string }) {...} // Aqui: // parse \u00e9 o verbo // ItemPrice \u00e9 o objeto direto function getRelativeShippingInfo() {...} // Aqui: // get \u00e9 o verbo // RelativeShippingInfo \u00e9 o objeto direto function extractUserDataFromTable({ userId }:{ userId: string }) {...} // Aqui: // extract \u00e9 o verbo // UserData \u00e9 o objeto direto // From \u00e9 uma preposi\u00e7\u00e3o auxiliar. Importante neste caso, pois, sem ela, // pareceria que o objeto direto \u00e9 UserDataTable // Table \u00e9 o objeto indireto // Outros bons exemplos: function calculateTotalCost() {...} function getDeliveryDate() {...} function saveUserData() {...} function validateForm() {...} function displayErrorMessage() {...} function deleteElement() {...} function fetchAiAPI() {...} Com TypeScript, alguns casos simples permitem o uso apenas do objeto direto, sem o verbo // Good \ud83d\ude00 function toNumber({ price }:{ price: string }) {...} // uma contra\u00e7\u00e3o de convertStringToNumber() Nomes ruins para fun\u00e7\u00f5es ou m\u00e9todos // Bad \ud83d\ude15 function deliveryDate() {...} // Falta o verbo. Delivery aqui significa entrega, um substantivo function func1() {...} // N\u00e3o diz nada function test() {...} // Testa o qu\u00ea? function fetch() {...} // Faz um fetch em qu\u00ea? function process() {...} // N\u00e3o diz nada function run() {...} // Executa o qu\u00ea?","title":"Nos nomes de fun\u00e7\u00f5es e m\u00e9todos:"},{"location":"1-Clean-Code/1-nomenclature/#nos-nomes-de-funcoes-e-propriedades-herdados-de-bibliotecas","text":"Nestes casos, como por exemplo uma fun\u00e7\u00e3o chamada fetch ou uma property chamada isLoading, , quando poss\u00edvel, sobrescrever tais nomes gen\u00e9ricos com nomes mais espec\u00edficos, no contexto do seu aplicativo, como por exemplo, isClientLoading ou fetchClientAccountData .","title":"Nos nomes de fun\u00e7\u00f5es e propriedades, herdados de bibliotecas:"},{"location":"1-Clean-Code/1-nomenclature/#nomes-de-componentes-react","text":"Os nomes dos componentes, ou objetos importados de bibliotecas, devem usar a conven\u00e7\u00e3o PascalCase , ou seja, todas as palavras iniciam com letra mai\u00fascula. Al\u00e9m disso, embora usemos componentes React funcionais, (que s\u00e3o fun\u00e7\u00f5es JavaScript, ao inv\u00e9s de classes), devemos usar substantivos ou substantivos compostos, sem uso do verbo, como no caso das vari\u00e1veis, pois os componentes representam principalmente coisas (embora contenham fun\u00e7\u00f5es). // Good \ud83d\ude00 function Buttom(...) {...} function RadioButton(...) {...} function MultilinesTextField(...) {...} function CancelOrderModal(...) {...} // A palavra 'Cancel', aqui, n\u00e3o est\u00e1 sendo usada como um // verbo (Cancelar) e, sim, como um adjetivo (Cancelamento) function SellerDetails(...) {...} function AdminProducts(...) {...} // Pode referir-se a uma lista function SellerCreation(...) {...} function SellerEdition(...) {...} function EmailActivation(...) {...} function Products(...) {...} // Bad \ud83d\ude15 function AdminProductsList(...) {...} // N\u00e3o usar a palavra List function CreateSeller(...) {...} // N\u00e3o deveria usar verbo function EditSeller(...) {...} // N\u00e3o deveria usar verbo function ListProducts(...) {...} // 'List' \u00e9 um verbo aqui e n\u00e3o deveria ser usado","title":"Nomes de componentes React:"},{"location":"1-Clean-Code/1-nomenclature/#113-usar-nomes-especificos-evitando-nomes-ambiguos-no-escopo","text":"Ser espec\u00edfico o suficiente para identificar o que est\u00e1 sendo referenciado de forma un\u00edvoca, no escopo, e preferencialmente, no projeto. Por exemplo, se o escopo \u00e9 uma fun\u00e7\u00e3o de um componente, e \u00e9 necess\u00e1rio salvar um array de 'Pedidos' (Orders) de um certo 'Vendedor' (Seller), podemos usar uma vari\u00e1vel chamada 'orders' para salvar o array , mesmo que sejam pedidos de um vendedor espec\u00edfico. Entretanto se o escopo desta vari\u00e1vel for o componente e for necess\u00e1rio criar um state para salvar o array de 'Pedidos', ainda de um vendedor espec\u00edfico, um nome melhor para este state seria sellerOrders, uma vez que apenas 'orders' subentende que o array salva todos os pedidos de todos os vendedores. Se a fun\u00e7\u00e3o for 'clean' e, portanto, pequena, esta ambiguidade n\u00e3o ocorrer\u00e1, pois ser\u00e1 evidente que 'orders' se refere a pedidos de um vendedor espec\u00edfico. J\u00e1 em um componente, onde o c\u00f3digo \u00e9 bem mais longo do que em uma fun\u00e7\u00e3o, essa ambiguidade n\u00e3o ser\u00e1 percebida com facilidade, deixando o c\u00f3digo mais obscuro e, por isso, a necessidade de nomear o 'state' de forma mais espec\u00edfica. De modo geral, quanto mais amplo o escopo, mais espec\u00edfico deve ser o nome, para impedir conflitos de entendimento. Assim, se estivermos nomeando uma fun\u00e7\u00e3o ou componente 'extern' que pode ser acessado por todo o programa, devemos tornar o nome espec\u00edfico o suficiente para que n\u00e3o possa ser confundido com algo semelhante no resto do sistema.","title":"1.1.3- Usar nomes espec\u00edficos, evitando nomes amb\u00edguos no escopo"},{"location":"1-Clean-Code/1-nomenclature/#114-ser-consistente-no-escopo-do-projeto","text":"Deve-se procurar usar os mesmos nomes e verbos para os mesmos tipos de conte\u00fado e/ou a\u00e7\u00f5es, dentro do projeto corrente e, se poss\u00edvel, entre todos os projetos da BuildBox. Por exemplo: // Bad \ud83d\ude15 getUserInfo() getClientData() getCustomerRecord() // Good \ud83d\ude00 getClient()","title":"1.1.4- Ser consistente no escopo do projeto"},{"location":"1-Clean-Code/1-nomenclature/#115-usar-aspas-simples","text":"Usar aspas simples (' ') nos literais de strings e nomes de propriedades, ao inv\u00e9s de aspas duplas (\" \").","title":"1.1.5- Usar aspas simples"},{"location":"1-Clean-Code/1-nomenclature/#116-nao-usar-export-default","text":"Nunca usar export default para exportar um componente React, de modo a obrigar o uso do nome espec\u00edfico na importa\u00e7\u00e3o.","title":"1.1.6- N\u00e3o usar export default"},{"location":"1-Clean-Code/2-code-format/","text":"1.2- Formata\u00e7\u00e3o do c\u00f3digo 1.2.1- Evitar coment\u00e1rios Os nomes dos componentes, fun\u00e7\u00f5es, objetos, vari\u00e1veis e argumentos devem ser autoexplicativos o suficiente, de modo a tornar os coment\u00e1rios desnecess\u00e1rios. Se os nomes forem autoexplicativos e o c\u00f3digo estiver limpo e leg\u00edvel, a maioria dos coment\u00e1rios se tornar\u00e3o dispens\u00e1veis e redudantes, e sua presen\u00e7a, al\u00e9m de dificultar a leitura do c\u00f3digo, poder\u00e1 levar a erros, ao ocorrerem modifica\u00e7\u00f5es no c\u00f3digo, sem a correspondente atualiza\u00e7\u00e3o do coment\u00e1rio original. Entretanto, os seguintes tipos de coment\u00e1rio s\u00e3o \u00fateis e, \u00e0s vezes, necess\u00e1rios: - Avisos de natureza jur\u00eddica - Premissas ou pr\u00e9-condi\u00e7\u00f5es para executar uma fun\u00e7\u00e3o - Explica\u00e7\u00f5es sobre algo impl\u00edcito: por exemplo Regex - TO DOs (Modifica\u00e7\u00f5es futuras no c\u00f3digo) Exemplos de coment\u00e1rios \u00fateis: function processPayment(cardNumber, expDate, cvv, amount) { /* This function processes credit card payments Legal: This code must comply with PCI DSS standards. Preconditions: The transaction amount must be > $0. Limitations: This function only supports Visa and Mastercard payments. */ // Function code goes here ... } // accepts [text]@[text].[text], i.e. it simply requires an \"@\" and a dot const emailRegex = /\\S+@\\S+\\.\\S+/; 1.2.2- Formata\u00e7\u00e3o horizontal M\u00e1ximo de 80 caracteres por linha Usar identa\u00e7\u00e3o para expressar o escopo N\u00e3o usar ponto e v\u00edrgula ao final das declara\u00e7\u00f5es, a menos que necess\u00e1rio... Usar aspas simples nas literais de strings e nomes de propriedades Para garantir as regras acima, crie ou substitua o arquivo de nome '.prettierrc', na pasta raiz do projeto, com o seguinte objeto: Isto far\u00e1 com que o plugin prettier salve o arquivo fonte com as regras de formata\u00e7\u00e3o horizontal, definidas acima. 1.2.3- Formata\u00e7\u00e3o vertical As fun\u00e7\u00f5es chamadoras devem estar acima das fun\u00e7\u00f5es chamadas, sempre que poss\u00edvel. Mantenha conceitos relacionados pr\u00f3ximos, ou seja, idealmente, mantenha as fun\u00e7\u00f5es chamadas imediatamente abaixo de suas fun\u00e7\u00f5es chamadoras. Use linhas em branco para separar conceitos n\u00e3o relacionados diretamente. Nos componentes React, os grupos de elementos devem vir na ordem abaixo: states fun\u00e7\u00f5es que tratam eventos da renderiza\u00e7\u00e3o ou s\u00e3o passadas para sub-componentes useEffects (Se houver uma sequ\u00eancia de atualiza\u00e7\u00e3o, disp\u00f4-los na ordem em que s\u00e3o chamados pela atualiza\u00e7\u00e3o dos states), e suas fun\u00e7\u00f5es associadas fun\u00e7\u00f5es que cooperam com a renderiza\u00e7\u00e3o, cujo nome deveria come\u00e7ar com render . (Idealmente, cada uma destas fun\u00e7\u00f5es deveria ser transformada em um componente React separado, mas em casos de fun\u00e7\u00f5es bem pequenas, talvez seja mais leg\u00edvel deix\u00e1-las, aqui, no componente cliente ) return de renderiza\u00e7\u00e3o do componente","title":"1.2- Formata\u00e7\u00e3o do c\u00f3digo"},{"location":"1-Clean-Code/2-code-format/#12-formatacao-do-codigo","text":"","title":"1.2- Formata\u00e7\u00e3o do c\u00f3digo"},{"location":"1-Clean-Code/2-code-format/#121-evitar-comentarios","text":"Os nomes dos componentes, fun\u00e7\u00f5es, objetos, vari\u00e1veis e argumentos devem ser autoexplicativos o suficiente, de modo a tornar os coment\u00e1rios desnecess\u00e1rios. Se os nomes forem autoexplicativos e o c\u00f3digo estiver limpo e leg\u00edvel, a maioria dos coment\u00e1rios se tornar\u00e3o dispens\u00e1veis e redudantes, e sua presen\u00e7a, al\u00e9m de dificultar a leitura do c\u00f3digo, poder\u00e1 levar a erros, ao ocorrerem modifica\u00e7\u00f5es no c\u00f3digo, sem a correspondente atualiza\u00e7\u00e3o do coment\u00e1rio original. Entretanto, os seguintes tipos de coment\u00e1rio s\u00e3o \u00fateis e, \u00e0s vezes, necess\u00e1rios: - Avisos de natureza jur\u00eddica - Premissas ou pr\u00e9-condi\u00e7\u00f5es para executar uma fun\u00e7\u00e3o - Explica\u00e7\u00f5es sobre algo impl\u00edcito: por exemplo Regex - TO DOs (Modifica\u00e7\u00f5es futuras no c\u00f3digo) Exemplos de coment\u00e1rios \u00fateis: function processPayment(cardNumber, expDate, cvv, amount) { /* This function processes credit card payments Legal: This code must comply with PCI DSS standards. Preconditions: The transaction amount must be > $0. Limitations: This function only supports Visa and Mastercard payments. */ // Function code goes here ... } // accepts [text]@[text].[text], i.e. it simply requires an \"@\" and a dot const emailRegex = /\\S+@\\S+\\.\\S+/;","title":"1.2.1- Evitar coment\u00e1rios"},{"location":"1-Clean-Code/2-code-format/#122-formatacao-horizontal","text":"M\u00e1ximo de 80 caracteres por linha Usar identa\u00e7\u00e3o para expressar o escopo N\u00e3o usar ponto e v\u00edrgula ao final das declara\u00e7\u00f5es, a menos que necess\u00e1rio... Usar aspas simples nas literais de strings e nomes de propriedades Para garantir as regras acima, crie ou substitua o arquivo de nome '.prettierrc', na pasta raiz do projeto, com o seguinte objeto: Isto far\u00e1 com que o plugin prettier salve o arquivo fonte com as regras de formata\u00e7\u00e3o horizontal, definidas acima.","title":"1.2.2- Formata\u00e7\u00e3o horizontal"},{"location":"1-Clean-Code/2-code-format/#123-formatacao-vertical","text":"As fun\u00e7\u00f5es chamadoras devem estar acima das fun\u00e7\u00f5es chamadas, sempre que poss\u00edvel. Mantenha conceitos relacionados pr\u00f3ximos, ou seja, idealmente, mantenha as fun\u00e7\u00f5es chamadas imediatamente abaixo de suas fun\u00e7\u00f5es chamadoras. Use linhas em branco para separar conceitos n\u00e3o relacionados diretamente. Nos componentes React, os grupos de elementos devem vir na ordem abaixo: states fun\u00e7\u00f5es que tratam eventos da renderiza\u00e7\u00e3o ou s\u00e3o passadas para sub-componentes useEffects (Se houver uma sequ\u00eancia de atualiza\u00e7\u00e3o, disp\u00f4-los na ordem em que s\u00e3o chamados pela atualiza\u00e7\u00e3o dos states), e suas fun\u00e7\u00f5es associadas fun\u00e7\u00f5es que cooperam com a renderiza\u00e7\u00e3o, cujo nome deveria come\u00e7ar com render . (Idealmente, cada uma destas fun\u00e7\u00f5es deveria ser transformada em um componente React separado, mas em casos de fun\u00e7\u00f5es bem pequenas, talvez seja mais leg\u00edvel deix\u00e1-las, aqui, no componente cliente ) return de renderiza\u00e7\u00e3o do componente","title":"1.2.3- Formata\u00e7\u00e3o vertical"},{"location":"1-Clean-Code/3-flow-control/","text":"1.3- Controle do fluxo 1.3.1- Preferir cl\u00e1usulas condicionais afirmativas, ao inv\u00e9s de negativas Exemplo: // Bad \ud83d\ude15 function isUserNotActive(node) { // ... } if (!isUserNotActive(node)) { // ... } // Good \ud83d\ude00 function isUserActive(node) { // ... } if ( isUserActive(node) ) { // ... } 1.3.2- Usar o m\u00ednimo aninhamento poss\u00edvel Usar cl\u00e1usulas condicionais de 'Prote\u00e7\u00e3o' Uma cl\u00e1usula condicional de prote\u00e7\u00e3o \u00e9 uma declara\u00e7\u00e3o 'if' que faz a fun\u00e7\u00e3o retornar, imediatamente, atrav\u00e9s de um 'return' ou de uma exce\u00e7\u00e3o (Error). Exemplo: // Bad \ud83d\ude15 function getPromotionalPrice(promotionCode) { let price if (promotionCode===PROMOTION_CODE1) { price = getPromotionCode1Price() } else { if (promotionCode===PROMOTION_CODE2) { price = getPromotionCode2Price() } else { if (promotionCode===PROMOTION_STUDENT) { price = getPromotionStudentPrice() } else { price = getDefaultPrice() } } } return price } // Better \ud83d\ude00 function getPromotionalPrice(promotionCode) { if (promotionCode===PROMOTION_CODE1) return getPromotionCode1Price() if (promotionCode===PROMOTION_CODE2) return getPromotionCode2Price() if (promotionCode===PROMOTION_STUDENT) return getPromotionStudentPrice() return getDefaultPrice() } Refatorar estruturas de controle em fun\u00e7\u00f5es separadas Observe o c\u00f3digo abaixo: // Bad \ud83d\ude15 function calculatePayment(age, isStudent, isMember) { let payment = 0 if (age < 18) { if (isStudent) { if (isMember) { if (age < 12) { payment = 5 } else { payment = 10 } } else { payment = 20 } } else { if (isMember) { if (age < 12) { payment = 7 } else { payment = 15 } } else { payment = 25 } } } else { if (isMember) { if (age >= 18 && age < 65) { if (isStudent) { payment = 3 } else { payment = 8 } } else { payment = 10 } } else { if (age >= 18 && age < 65) { if (isStudent) { payment = 5 } else { payment = 15 } } else { payment = 20 } } } return payment } Al\u00e9m de ser uma fun\u00e7\u00e3o muito longa (50 linhas), chega a ter at\u00e9 5 n\u00edveis de aninhamento, o que a torna dif\u00edcil de ler e compreender. Note como a vers\u00e3o desse c\u00f3digo, abaixo, onde v\u00e1rias estruturas de controle foram refatoradas em fun\u00e7\u00f5es, se torna bem mais f\u00e1cil de entender. // Much better! \ud83d\ude00 function calculatePayment(age, isStudent, isMember) { if( isUnderage(age) ) return calculateUnderagePayment(isStudent, isMember, age) if (isAdult(age)) return calculateAdultPayment(isStudent, isMember, age) return calculateSeniorPayment() } function isUnderage(age) { return age < 18 } function isAdult(age) { return age >= 18 && age < 65 } function calculateUnderagePayment(isStudent, isMember, age) { if (isStudent) { return calculateUnderageStudentPayment(isMember, age) } else { return calculateUnderageNonStudentPayment(isMember, age) } } function calculateUnderageStudentPayment(isMember, age) { if (isMember) { return age < 12 ? 5 : 10 } else { return 20 } } function calculateUnderageNonStudentPayment(isMember, age) { if (isMember) { return age < 12 ? 7 : 15 } else { return 25 } } function calculateAdultPayment(isStudent, isMember, age) { if (isMember) { return calculateAdultMemberPayment(isStudent, age) } else { return calculateAdultNonMemberPayment(isStudent, age) } } function calculateAdultMemberPayment(isStudent, age) { return isStudent ? 3 : 8 } function calculateAdultNonMemberPayment(isStudent, age) { return isStudent ? 5 : 15 } function calculateSeniorPayment() { return 20 } Embora o c\u00f3digo final ainda tenha 51 linhas, fica f\u00e1cil de entender o que cada fun\u00e7\u00e3o faz, porque cada grupo de condicionais foi encapsulado em uma fun\u00e7\u00e3o pequena e com um apenas 1 n\u00edvel de aninhamento. 1.3.3- Substituir declara\u00e7\u00f5es switch/if por literais de objetos // Bad \ud83d\ude15 const getServerUrl = (env) => { switch (env) { case \"prod\": return \"prod.myweb.com\" case \"test\": return \"test.myweb.com\" case \"staging\": return \"staging.myweb.com\" default: return \"https://localhost:3000\" } } // Better \ud83d\ude00 const serverUrls = { prod: \"prod.myweb.com\", test: \"test.myweb.com\", staging: \"staging.myweb.com\" } const getServerUrl = (env) => serverUrls[env] || \"https://localhost:3000\" 1.3.4- Usar Exceptions para tratar erros Todos os tipos de erro que impe\u00e7am o fluxo do programa de continuar ou de produzir resultados corretos, devem ser previstos e tratados por meio de exce\u00e7\u00f5es ( try catch ). A id\u00e9ia b\u00e1sica \u00e9 validar todas as vari\u00e1veis que ser\u00e3o utilizadas em determinado processamento e subir uma exce\u00e7\u00e3o, caso alguma delas tenha um valor inv\u00e1lido, antes da execu\u00e7\u00e3o do processamento em quest\u00e3o. A se\u00e7\u00e3o Design Patterns / Tratamento de erros detalha a forma padr\u00e3o como isso deve ser feito no c\u00f3digo da BuildBox.","title":"1.3- Controle do fluxo"},{"location":"1-Clean-Code/3-flow-control/#13-controle-do-fluxo","text":"","title":"1.3- Controle do fluxo"},{"location":"1-Clean-Code/3-flow-control/#131-preferir-clausulas-condicionais-afirmativas-ao-inves-de-negativas","text":"Exemplo: // Bad \ud83d\ude15 function isUserNotActive(node) { // ... } if (!isUserNotActive(node)) { // ... } // Good \ud83d\ude00 function isUserActive(node) { // ... } if ( isUserActive(node) ) { // ... }","title":"1.3.1- Preferir cl\u00e1usulas condicionais afirmativas, ao inv\u00e9s de negativas"},{"location":"1-Clean-Code/3-flow-control/#132-usar-o-minimo-aninhamento-possivel","text":"","title":"1.3.2- Usar o m\u00ednimo aninhamento poss\u00edvel"},{"location":"1-Clean-Code/3-flow-control/#usar-clausulas-condicionais-de-protecao","text":"Uma cl\u00e1usula condicional de prote\u00e7\u00e3o \u00e9 uma declara\u00e7\u00e3o 'if' que faz a fun\u00e7\u00e3o retornar, imediatamente, atrav\u00e9s de um 'return' ou de uma exce\u00e7\u00e3o (Error). Exemplo: // Bad \ud83d\ude15 function getPromotionalPrice(promotionCode) { let price if (promotionCode===PROMOTION_CODE1) { price = getPromotionCode1Price() } else { if (promotionCode===PROMOTION_CODE2) { price = getPromotionCode2Price() } else { if (promotionCode===PROMOTION_STUDENT) { price = getPromotionStudentPrice() } else { price = getDefaultPrice() } } } return price } // Better \ud83d\ude00 function getPromotionalPrice(promotionCode) { if (promotionCode===PROMOTION_CODE1) return getPromotionCode1Price() if (promotionCode===PROMOTION_CODE2) return getPromotionCode2Price() if (promotionCode===PROMOTION_STUDENT) return getPromotionStudentPrice() return getDefaultPrice() }","title":"Usar cl\u00e1usulas condicionais de 'Prote\u00e7\u00e3o'"},{"location":"1-Clean-Code/3-flow-control/#refatorar-estruturas-de-controle-em-funcoes-separadas","text":"Observe o c\u00f3digo abaixo: // Bad \ud83d\ude15 function calculatePayment(age, isStudent, isMember) { let payment = 0 if (age < 18) { if (isStudent) { if (isMember) { if (age < 12) { payment = 5 } else { payment = 10 } } else { payment = 20 } } else { if (isMember) { if (age < 12) { payment = 7 } else { payment = 15 } } else { payment = 25 } } } else { if (isMember) { if (age >= 18 && age < 65) { if (isStudent) { payment = 3 } else { payment = 8 } } else { payment = 10 } } else { if (age >= 18 && age < 65) { if (isStudent) { payment = 5 } else { payment = 15 } } else { payment = 20 } } } return payment } Al\u00e9m de ser uma fun\u00e7\u00e3o muito longa (50 linhas), chega a ter at\u00e9 5 n\u00edveis de aninhamento, o que a torna dif\u00edcil de ler e compreender. Note como a vers\u00e3o desse c\u00f3digo, abaixo, onde v\u00e1rias estruturas de controle foram refatoradas em fun\u00e7\u00f5es, se torna bem mais f\u00e1cil de entender. // Much better! \ud83d\ude00 function calculatePayment(age, isStudent, isMember) { if( isUnderage(age) ) return calculateUnderagePayment(isStudent, isMember, age) if (isAdult(age)) return calculateAdultPayment(isStudent, isMember, age) return calculateSeniorPayment() } function isUnderage(age) { return age < 18 } function isAdult(age) { return age >= 18 && age < 65 } function calculateUnderagePayment(isStudent, isMember, age) { if (isStudent) { return calculateUnderageStudentPayment(isMember, age) } else { return calculateUnderageNonStudentPayment(isMember, age) } } function calculateUnderageStudentPayment(isMember, age) { if (isMember) { return age < 12 ? 5 : 10 } else { return 20 } } function calculateUnderageNonStudentPayment(isMember, age) { if (isMember) { return age < 12 ? 7 : 15 } else { return 25 } } function calculateAdultPayment(isStudent, isMember, age) { if (isMember) { return calculateAdultMemberPayment(isStudent, age) } else { return calculateAdultNonMemberPayment(isStudent, age) } } function calculateAdultMemberPayment(isStudent, age) { return isStudent ? 3 : 8 } function calculateAdultNonMemberPayment(isStudent, age) { return isStudent ? 5 : 15 } function calculateSeniorPayment() { return 20 } Embora o c\u00f3digo final ainda tenha 51 linhas, fica f\u00e1cil de entender o que cada fun\u00e7\u00e3o faz, porque cada grupo de condicionais foi encapsulado em uma fun\u00e7\u00e3o pequena e com um apenas 1 n\u00edvel de aninhamento.","title":"Refatorar estruturas de controle em fun\u00e7\u00f5es separadas"},{"location":"1-Clean-Code/3-flow-control/#133-substituir-declaracoes-switchif-por-literais-de-objetos","text":"// Bad \ud83d\ude15 const getServerUrl = (env) => { switch (env) { case \"prod\": return \"prod.myweb.com\" case \"test\": return \"test.myweb.com\" case \"staging\": return \"staging.myweb.com\" default: return \"https://localhost:3000\" } } // Better \ud83d\ude00 const serverUrls = { prod: \"prod.myweb.com\", test: \"test.myweb.com\", staging: \"staging.myweb.com\" } const getServerUrl = (env) => serverUrls[env] || \"https://localhost:3000\"","title":"1.3.3- Substituir declara\u00e7\u00f5es switch/if por literais de objetos"},{"location":"1-Clean-Code/3-flow-control/#134-usar-exceptions-para-tratar-erros","text":"Todos os tipos de erro que impe\u00e7am o fluxo do programa de continuar ou de produzir resultados corretos, devem ser previstos e tratados por meio de exce\u00e7\u00f5es ( try catch ). A id\u00e9ia b\u00e1sica \u00e9 validar todas as vari\u00e1veis que ser\u00e3o utilizadas em determinado processamento e subir uma exce\u00e7\u00e3o, caso alguma delas tenha um valor inv\u00e1lido, antes da execu\u00e7\u00e3o do processamento em quest\u00e3o. A se\u00e7\u00e3o Design Patterns / Tratamento de erros detalha a forma padr\u00e3o como isso deve ser feito no c\u00f3digo da BuildBox.","title":"1.3.4- Usar Exceptions para tratar erros"},{"location":"1-Clean-Code/4-functions/","text":"1.4- Fun\u00e7\u00f5es e m\u00e9todos 1.4.1- Usar o DRY ( D on't R epeat Y ourselt) C\u00f3digo que tem o potencial de ser usado em outros lugares do sistema, ou seja, \u00e9 gen\u00e9rico, deve ser escrito (encapsulado) dentro de uma fun\u00e7\u00e3o (que poder\u00e1, por sua vez, chamar outras fun\u00e7\u00f5es). Em outras palavras, n\u00e3o escreva o mesmo c\u00f3digo ou c\u00f3digo muito parecido em mais de um lugar, no sistema. Se ocorrer a necessidade de fazer isso, encapsule tal c\u00f3digo em uma fun\u00e7\u00e3o reus\u00e1vel. Isto facilita o entendimento desse c\u00f3digo por outros desenvolvedores, incluindo voc\u00ea, no futuro, e facilita a manuten\u00e7\u00e3o e expans\u00e3o futuras desse c\u00f3digo. 1.4.2- As fun\u00e7\u00f5es devem fazer apenas uma coisa (Single Responsability Principle) Note que 'fazer apenas uma coisa', aqui, tem um significado especial. Certamente, a maioria das fun\u00e7\u00f5es que criamos faz mais de uma coisa, e tais fun\u00e7\u00f5es n\u00e3o teriam raz\u00e3o de existir n\u00e3o fosse esse fato. Para entendermos o que 'fazer apenas uma coisa' significa, aqui, precisamos explicar um conceito chamado de n\u00edvel de abstra\u00e7\u00e3o . Vamos explicar este conceito com uma ilustra\u00e7\u00e3o concreta. Imagine que voc\u00ea queira realizar uma tarefa de processar um pagamento, que consista na execu\u00e7\u00e3o de 100 passos, em sequ\u00eancia. Como organizaria essa tarefa em JavaScript? Definiria uma \u00fanica fun\u00e7\u00e3o, por exemplo processPayment() , e executaria os 100 passos dentro dessa fun\u00e7\u00e3o? Certamente, essa solu\u00e7\u00e3o n\u00e3o deixaria o c\u00f3digo claro, f\u00e1cil de entender e de manter. Uma solu\u00e7\u00e3o melhor seria: Organizar os 100 passos em 20 grupos de aproximadamente 5 passos, cada. Criar 20 fun\u00e7\u00f5es adicionais, cada uma para executar os passos dentro de cada um desses 20 grupos. Dizemos, ent\u00e3o, que os passos est\u00e3o no n\u00edvel 1 de abstra\u00e7\u00e3o e que as 20 fun\u00e7\u00f5es que executam cada grupo de passos est\u00e3o em um n\u00edvel de abstra\u00e7\u00e3o superior, que chamamos de n\u00edvel 2. Oganizar as 20 fun\u00e7\u00f5es em 4 novos grupos, com 5 fun\u00e7\u00f5es do n\u00edvel 2, em cada um desses 4 grupos. Criar 4 fun\u00e7\u00f5es para executar as fun\u00e7\u00f5es de cada um desses 4 grupos. Agora, podemos dizer que essas 4 novas fun\u00e7\u00f5es est\u00e3o no n\u00edvel 3 de abstra\u00e7\u00e3o. E, por fim, dizemos que o n\u00edvel de abstra\u00e7\u00e3o da fun\u00e7\u00e3o principal, processPayment() , \u00e9 o n\u00edvel 4 de abstra\u00e7\u00e3o. Esta ilustra\u00e7\u00e3o nos permite, ent\u00e3o, explicar que: 'fazer apenas uma coisa' significa fazer apenas uma coisa no n\u00edvel de abstra\u00e7\u00e3o descrito pelo nome da fun\u00e7\u00e3o. E, portanto, o t\u00edtulo desta se\u00e7\u00e3o significa que uma fun\u00e7\u00e3o deve fazer apenas uma coisa no n\u00edvel de abstra\u00e7\u00e3o descrito pelo seu nome . Finalmente, podemos, tamb\u00e9m, estabelecer mais 2 regras que nos ajudam a organizar, de forma clara, o trabalho a ser feito por meio de fun\u00e7\u00f5es: O n\u00edvel de abstra\u00e7\u00e3o do c\u00f3digo, dentro de uma fun\u00e7\u00e3o, deve ser um n\u00edvel abaixo do n\u00edvel impl\u00edcito no nome da fun\u00e7\u00e3o. Deve-se evitar misturar n\u00edveis de abstra\u00e7\u00e3o dentro de fun\u00e7\u00f5es. Ou seja, qualquer coisa que n\u00e3o se encaixe no n\u00edvel abaixo do nome, deve ser codificado em outro lugar. Vamos mostrar um exemplo em c\u00f3digo para ajudar na compreens\u00e3o de tudo o que foi dito. Considere a fun\u00e7\u00e3o renderElement() , abaixo. function renderElement(dataToRender) { const element = dataToRender.element if (element === 'script' || element === 'SCRIPT') { throw new Error('Invalid element.') } let partialOpeningTag = '<' + element const attributes = dataToRender.attributes for (const attribute of attributes) { partialOpeningTag = partialOpeningTag + ' ' + attribute.name + '=\"' + attribute.value + '\"'; } const openingTag = partialOpeningTag + '>' const closingTag = '<!--' + element + '-->' const content = dataToRender.content const template = openingTag + content + closingTag const rootElement = dataToRender.root rootElement.innerHTML = template } Embora o c\u00f3digo acima n\u00e3o seja dif\u00edcil de ler, veja, abaixo, o que acontece quando refactoramos esse c\u00f3digo, utilizando os conceitos desta se\u00e7\u00e3o: function renderElement(dataToRender) { const element = dataToRender.element validateElementType(element) dataToRender.root.innerHTML = buildOpenningTag( element, buildAttributesList(dataToRender.attributes) ) + dataToRender.content + buildClosingTag(element) } function validateElementType(element) { if (element === 'script' || element === 'SCRIPT') { throw new Error('Invalid element.') } } function buildAttributesList(attributes) { let attributeList = '' for (const attribute of attributes) { attributeList = `${attributeList} ${attribute.name}=\"${attribute.value}\"` } return attributeList; } function buildOpenningTag(element, attributes) { return( '<' + element + attributes + '>' ) } function buildClosingTag(element) { return( tag = '<!--' + element + '-->' ) } Observe como o comportamento da fun\u00e7\u00e3o renderElement() , agora, ficou expl\u00edcito, f\u00e1cil de ler e como seu c\u00f3digo foi refatorado em 4 fun\u00e7\u00f5es perfeitamente claras e reus\u00e1veis em outras partes do sistema. Note os n\u00edveis de abstra\u00e7\u00e3o de que falamos anteriormente, no n\u00edvel 1, temos o conte\u00fado das fun\u00e7\u00f5es buildAttributesList() , buildOpenningTag() e buildClosingTag() , no n\u00edvel 2 temos essas tr\u00eas fun\u00e7\u00f5es e no n\u00edvel 3, temos a fun\u00e7\u00e3o renderElement() . Por fim, observe que a atribui\u00e7\u00e3o direta da propriedade dataToRender.root.innerHTML n\u00e3o atende a regra 2, acima, porque essa atribui\u00e7\u00e3o \u00e9 uma a\u00e7\u00e3o que manipula direto o conte\u00fado do DOM e est\u00e1 mais para algo do n\u00edvel 1 do que do n\u00edvel 2. Nesse caso, entretanto, abrimos uma exce\u00e7\u00e3o porque, para resolver isso, ter\u00edamos de criar uma fun\u00e7\u00e3o que receberia o elemento root e o conte\u00fado, como par\u00e2metros, para, depois, apenas fazer a atribui\u00e7\u00e3o da propriedade innerHTML . Ou seja, neste caso, o atendimento da regra 2 acabaria deixando o c\u00f3digo polu\u00eddo e menos claro e, portanto, n\u00e3o vale a pena seguir a regra 2. 1.4.3- Limitar o n\u00famero de argumentos das fun\u00e7\u00f5es Quanto menos argumentos, melhor A partir de 2 argumentos torna-se necess\u00e1rio mapear cada par\u00e2metro, na chamada da fun\u00e7\u00e3o, a cada argumento da declara\u00e7\u00e3o da fun\u00e7\u00e3o. Isto \u00e9 uma informa\u00e7\u00e3o impl\u00edcita que demanda tempo do desenvolvedor. Al\u00e9m disso, o aumento do n\u00famero de par\u00e2metros aumenta exponencialmente o n\u00famero de casos de teste para se testar uma fun\u00e7\u00e3o. Usar objetos ou arrays para agrupar m\u00faltiplos par\u00e2metros em um \u00fanico Caso n\u00e3o seja poss\u00edvel manter apenas 1 ou 2 argumentos, deve-se usar, na chamada da fun\u00e7\u00e3o, um objeto com os mesmos nomes dos argumentos, de modo a tornar expl\u00edcito o que significa cada par\u00e2metro passado, como no exemplo abaixo. // Bad \ud83d\ude15 function compare(first, second, comparator) { if (comparator === 'equal') return first === second if (comparator === 'not equal') return first !== second if (comparator === 'greater') return first > second if (comparator === 'smaller') return first < second } const isSmaller = compare(3, 5, 'smaller') const isEqual = compare(3, 5, 'equal') // Good \ud83d\ude00 function compare(comparisonData) { const { first, second, comparator } = comparisonData if (comparator === 'equal') return first === second if (comparator === 'not equal') return first !== second if (comparator === 'greater') return first > second if (comparator === 'smaller') return first < second } const isSmaller = compare({ first: 3, second: 5, comparator: 'smaller' }) N\u00e3o usar argumentos como flags Flags indicam que a fun\u00e7\u00e3o faz mais de uma coisa e, nesse caso, a fun\u00e7\u00e3o deveria ser dividida em 2 ou mais fun\u00e7\u00f5es. // Bad \ud83d\ude15 function createFile(name, temp) { if (temp) { fs.create(`./temp/${name}`) } else { fs.create(name) } } // Good \ud83d\ude00 function createFile(name) { fs.create(name) } function createTempFile(name) { createFile(`./temp/${name}`) } 1.4.4- Usar par\u00e2metros default Usar argumentos default, quando poss\u00edvel, reduz o n\u00famero de testes condicionais dentro da fun\u00e7\u00e3o. 1.4.5- Evitar efeitos colaterais das fun\u00e7\u00f5es Uma fun\u00e7\u00e3o produz um efeito colateral quando ela envia ou escreve informa\u00e7\u00f5es em qualquer coisa al\u00e9m de receber par\u00e2metros e retornar valores. Um efeito colateral pode ser, por exemplo, escrever em um arquivo, modificar uma vari\u00e1vel global ou modificar um argumento mut\u00e1vel passado como par\u00e2metro, como por exemplo um array ou objeto. Acessar recursos externos \u00e9 necess\u00e1rio, como por exemplo acessar um banco de dados. Nestes casos, o que deve ser feito \u00e9 centralizar onde isso \u00e9 feito em um conjunto de fun\u00e7\u00f5es, componente ou servi\u00e7o designados para tal fim. O acesso ao recurso n\u00e3o deve ser feito de qualquer lugar, sem crit\u00e9rio, e deve sempre passar pelos m\u00e9todos ou fun\u00e7\u00f5es do Componente ou Servi\u00e7o designado para isso. No caso de par\u00e2metros mut\u00e1veis, passados como argumentos para uma fun\u00e7\u00e3o, caso seja necess\u00e1rio transformar esse conte\u00fado passado como par\u00e2metro, o que deve ser feito \u00e9 criar uma c\u00f3pia profunda do objeto em quest\u00e3o, transformar tal objeto e retornar a c\u00f3pia modificada como resultado da fun\u00e7\u00e3o. O resultado de uma fun\u00e7\u00e3o nunca deve ser 'retornado' no objeto passado como par\u00e2metro.","title":"1.4- Fun\u00e7\u00f5es e m\u00e9todos"},{"location":"1-Clean-Code/4-functions/#14-funcoes-e-metodos","text":"","title":"1.4- Fun\u00e7\u00f5es e m\u00e9todos"},{"location":"1-Clean-Code/4-functions/#141-usar-o-dry-dont-repeat-yourselt","text":"C\u00f3digo que tem o potencial de ser usado em outros lugares do sistema, ou seja, \u00e9 gen\u00e9rico, deve ser escrito (encapsulado) dentro de uma fun\u00e7\u00e3o (que poder\u00e1, por sua vez, chamar outras fun\u00e7\u00f5es). Em outras palavras, n\u00e3o escreva o mesmo c\u00f3digo ou c\u00f3digo muito parecido em mais de um lugar, no sistema. Se ocorrer a necessidade de fazer isso, encapsule tal c\u00f3digo em uma fun\u00e7\u00e3o reus\u00e1vel. Isto facilita o entendimento desse c\u00f3digo por outros desenvolvedores, incluindo voc\u00ea, no futuro, e facilita a manuten\u00e7\u00e3o e expans\u00e3o futuras desse c\u00f3digo.","title":"1.4.1- Usar o DRY (Don't Repeat Yourselt)  "},{"location":"1-Clean-Code/4-functions/#142-as-funcoes-devem-fazer-apenas-uma-coisa-single-responsability-principle","text":"Note que 'fazer apenas uma coisa', aqui, tem um significado especial. Certamente, a maioria das fun\u00e7\u00f5es que criamos faz mais de uma coisa, e tais fun\u00e7\u00f5es n\u00e3o teriam raz\u00e3o de existir n\u00e3o fosse esse fato. Para entendermos o que 'fazer apenas uma coisa' significa, aqui, precisamos explicar um conceito chamado de n\u00edvel de abstra\u00e7\u00e3o . Vamos explicar este conceito com uma ilustra\u00e7\u00e3o concreta. Imagine que voc\u00ea queira realizar uma tarefa de processar um pagamento, que consista na execu\u00e7\u00e3o de 100 passos, em sequ\u00eancia. Como organizaria essa tarefa em JavaScript? Definiria uma \u00fanica fun\u00e7\u00e3o, por exemplo processPayment() , e executaria os 100 passos dentro dessa fun\u00e7\u00e3o? Certamente, essa solu\u00e7\u00e3o n\u00e3o deixaria o c\u00f3digo claro, f\u00e1cil de entender e de manter. Uma solu\u00e7\u00e3o melhor seria: Organizar os 100 passos em 20 grupos de aproximadamente 5 passos, cada. Criar 20 fun\u00e7\u00f5es adicionais, cada uma para executar os passos dentro de cada um desses 20 grupos. Dizemos, ent\u00e3o, que os passos est\u00e3o no n\u00edvel 1 de abstra\u00e7\u00e3o e que as 20 fun\u00e7\u00f5es que executam cada grupo de passos est\u00e3o em um n\u00edvel de abstra\u00e7\u00e3o superior, que chamamos de n\u00edvel 2. Oganizar as 20 fun\u00e7\u00f5es em 4 novos grupos, com 5 fun\u00e7\u00f5es do n\u00edvel 2, em cada um desses 4 grupos. Criar 4 fun\u00e7\u00f5es para executar as fun\u00e7\u00f5es de cada um desses 4 grupos. Agora, podemos dizer que essas 4 novas fun\u00e7\u00f5es est\u00e3o no n\u00edvel 3 de abstra\u00e7\u00e3o. E, por fim, dizemos que o n\u00edvel de abstra\u00e7\u00e3o da fun\u00e7\u00e3o principal, processPayment() , \u00e9 o n\u00edvel 4 de abstra\u00e7\u00e3o. Esta ilustra\u00e7\u00e3o nos permite, ent\u00e3o, explicar que: 'fazer apenas uma coisa' significa fazer apenas uma coisa no n\u00edvel de abstra\u00e7\u00e3o descrito pelo nome da fun\u00e7\u00e3o. E, portanto, o t\u00edtulo desta se\u00e7\u00e3o significa que uma fun\u00e7\u00e3o deve fazer apenas uma coisa no n\u00edvel de abstra\u00e7\u00e3o descrito pelo seu nome . Finalmente, podemos, tamb\u00e9m, estabelecer mais 2 regras que nos ajudam a organizar, de forma clara, o trabalho a ser feito por meio de fun\u00e7\u00f5es: O n\u00edvel de abstra\u00e7\u00e3o do c\u00f3digo, dentro de uma fun\u00e7\u00e3o, deve ser um n\u00edvel abaixo do n\u00edvel impl\u00edcito no nome da fun\u00e7\u00e3o. Deve-se evitar misturar n\u00edveis de abstra\u00e7\u00e3o dentro de fun\u00e7\u00f5es. Ou seja, qualquer coisa que n\u00e3o se encaixe no n\u00edvel abaixo do nome, deve ser codificado em outro lugar. Vamos mostrar um exemplo em c\u00f3digo para ajudar na compreens\u00e3o de tudo o que foi dito. Considere a fun\u00e7\u00e3o renderElement() , abaixo. function renderElement(dataToRender) { const element = dataToRender.element if (element === 'script' || element === 'SCRIPT') { throw new Error('Invalid element.') } let partialOpeningTag = '<' + element const attributes = dataToRender.attributes for (const attribute of attributes) { partialOpeningTag = partialOpeningTag + ' ' + attribute.name + '=\"' + attribute.value + '\"'; } const openingTag = partialOpeningTag + '>' const closingTag = '<!--' + element + '-->' const content = dataToRender.content const template = openingTag + content + closingTag const rootElement = dataToRender.root rootElement.innerHTML = template } Embora o c\u00f3digo acima n\u00e3o seja dif\u00edcil de ler, veja, abaixo, o que acontece quando refactoramos esse c\u00f3digo, utilizando os conceitos desta se\u00e7\u00e3o: function renderElement(dataToRender) { const element = dataToRender.element validateElementType(element) dataToRender.root.innerHTML = buildOpenningTag( element, buildAttributesList(dataToRender.attributes) ) + dataToRender.content + buildClosingTag(element) } function validateElementType(element) { if (element === 'script' || element === 'SCRIPT') { throw new Error('Invalid element.') } } function buildAttributesList(attributes) { let attributeList = '' for (const attribute of attributes) { attributeList = `${attributeList} ${attribute.name}=\"${attribute.value}\"` } return attributeList; } function buildOpenningTag(element, attributes) { return( '<' + element + attributes + '>' ) } function buildClosingTag(element) { return( tag = '<!--' + element + '-->' ) } Observe como o comportamento da fun\u00e7\u00e3o renderElement() , agora, ficou expl\u00edcito, f\u00e1cil de ler e como seu c\u00f3digo foi refatorado em 4 fun\u00e7\u00f5es perfeitamente claras e reus\u00e1veis em outras partes do sistema. Note os n\u00edveis de abstra\u00e7\u00e3o de que falamos anteriormente, no n\u00edvel 1, temos o conte\u00fado das fun\u00e7\u00f5es buildAttributesList() , buildOpenningTag() e buildClosingTag() , no n\u00edvel 2 temos essas tr\u00eas fun\u00e7\u00f5es e no n\u00edvel 3, temos a fun\u00e7\u00e3o renderElement() . Por fim, observe que a atribui\u00e7\u00e3o direta da propriedade dataToRender.root.innerHTML n\u00e3o atende a regra 2, acima, porque essa atribui\u00e7\u00e3o \u00e9 uma a\u00e7\u00e3o que manipula direto o conte\u00fado do DOM e est\u00e1 mais para algo do n\u00edvel 1 do que do n\u00edvel 2. Nesse caso, entretanto, abrimos uma exce\u00e7\u00e3o porque, para resolver isso, ter\u00edamos de criar uma fun\u00e7\u00e3o que receberia o elemento root e o conte\u00fado, como par\u00e2metros, para, depois, apenas fazer a atribui\u00e7\u00e3o da propriedade innerHTML . Ou seja, neste caso, o atendimento da regra 2 acabaria deixando o c\u00f3digo polu\u00eddo e menos claro e, portanto, n\u00e3o vale a pena seguir a regra 2.","title":"1.4.2- As fun\u00e7\u00f5es devem fazer apenas uma coisa (Single Responsability Principle)"},{"location":"1-Clean-Code/4-functions/#143-limitar-o-numero-de-argumentos-das-funcoes","text":"Quanto menos argumentos, melhor A partir de 2 argumentos torna-se necess\u00e1rio mapear cada par\u00e2metro, na chamada da fun\u00e7\u00e3o, a cada argumento da declara\u00e7\u00e3o da fun\u00e7\u00e3o. Isto \u00e9 uma informa\u00e7\u00e3o impl\u00edcita que demanda tempo do desenvolvedor. Al\u00e9m disso, o aumento do n\u00famero de par\u00e2metros aumenta exponencialmente o n\u00famero de casos de teste para se testar uma fun\u00e7\u00e3o. Usar objetos ou arrays para agrupar m\u00faltiplos par\u00e2metros em um \u00fanico Caso n\u00e3o seja poss\u00edvel manter apenas 1 ou 2 argumentos, deve-se usar, na chamada da fun\u00e7\u00e3o, um objeto com os mesmos nomes dos argumentos, de modo a tornar expl\u00edcito o que significa cada par\u00e2metro passado, como no exemplo abaixo. // Bad \ud83d\ude15 function compare(first, second, comparator) { if (comparator === 'equal') return first === second if (comparator === 'not equal') return first !== second if (comparator === 'greater') return first > second if (comparator === 'smaller') return first < second } const isSmaller = compare(3, 5, 'smaller') const isEqual = compare(3, 5, 'equal') // Good \ud83d\ude00 function compare(comparisonData) { const { first, second, comparator } = comparisonData if (comparator === 'equal') return first === second if (comparator === 'not equal') return first !== second if (comparator === 'greater') return first > second if (comparator === 'smaller') return first < second } const isSmaller = compare({ first: 3, second: 5, comparator: 'smaller' }) N\u00e3o usar argumentos como flags Flags indicam que a fun\u00e7\u00e3o faz mais de uma coisa e, nesse caso, a fun\u00e7\u00e3o deveria ser dividida em 2 ou mais fun\u00e7\u00f5es. // Bad \ud83d\ude15 function createFile(name, temp) { if (temp) { fs.create(`./temp/${name}`) } else { fs.create(name) } } // Good \ud83d\ude00 function createFile(name) { fs.create(name) } function createTempFile(name) { createFile(`./temp/${name}`) }","title":"1.4.3- Limitar o n\u00famero de argumentos das fun\u00e7\u00f5es"},{"location":"1-Clean-Code/4-functions/#144-usar-parametros-default","text":"Usar argumentos default, quando poss\u00edvel, reduz o n\u00famero de testes condicionais dentro da fun\u00e7\u00e3o.","title":"1.4.4- Usar par\u00e2metros default"},{"location":"1-Clean-Code/4-functions/#145-evitar-efeitos-colaterais-das-funcoes","text":"Uma fun\u00e7\u00e3o produz um efeito colateral quando ela envia ou escreve informa\u00e7\u00f5es em qualquer coisa al\u00e9m de receber par\u00e2metros e retornar valores. Um efeito colateral pode ser, por exemplo, escrever em um arquivo, modificar uma vari\u00e1vel global ou modificar um argumento mut\u00e1vel passado como par\u00e2metro, como por exemplo um array ou objeto. Acessar recursos externos \u00e9 necess\u00e1rio, como por exemplo acessar um banco de dados. Nestes casos, o que deve ser feito \u00e9 centralizar onde isso \u00e9 feito em um conjunto de fun\u00e7\u00f5es, componente ou servi\u00e7o designados para tal fim. O acesso ao recurso n\u00e3o deve ser feito de qualquer lugar, sem crit\u00e9rio, e deve sempre passar pelos m\u00e9todos ou fun\u00e7\u00f5es do Componente ou Servi\u00e7o designado para isso. No caso de par\u00e2metros mut\u00e1veis, passados como argumentos para uma fun\u00e7\u00e3o, caso seja necess\u00e1rio transformar esse conte\u00fado passado como par\u00e2metro, o que deve ser feito \u00e9 criar uma c\u00f3pia profunda do objeto em quest\u00e3o, transformar tal objeto e retornar a c\u00f3pia modificada como resultado da fun\u00e7\u00e3o. O resultado de uma fun\u00e7\u00e3o nunca deve ser 'retornado' no objeto passado como par\u00e2metro.","title":"1.4.5- Evitar efeitos colaterais das fun\u00e7\u00f5es"},{"location":"1-Clean-Code/5-vscode-config/","text":"1.5- Configura\u00e7\u00e3o VSCode 1.5.1- Baixar o VSCode 1.5.2- Instalar as seguintes extens\u00f5es no VSCode: Prettier , ESLint e TSLint 1.5.3- Instalar as extens\u00f5es e pacotes globalmente com os comando abaixo: npm install -g tslint npm install -g eslint 1.5.4- Usar a configura\u00e7\u00e3o abaixo como configura\u00e7\u00e3o default do VSCode \"files.eol\": \"\\n\", \"editor.insertSpaces\": false, \"editor.renderWhitespace\": \"all\", \"editor.detectIndentation\": false, \"editor.tabSize\": 4, \"editor.renderControlCharacters\": true, \"editor.tabCompletion\": \"on\", \"editor.formatOnSave\": true, \"eslint.enable\": true, \"prettier.semi\": false, \"prettier.printWidth\": 120, \"prettier.useTabs\": true, \"prettier.tabWidth\": 4, \"prettier.singleQuote\": true, \"prettier.jsxBracketSameLine\": true, \"prettier.eslintIntegration\": true, \"prettier.tslintIntegration\": true 1.5.5- Fonte opcional com Ligadures \"terminal.integrated.fontSize\": 14, \"editor.fontFamily\": \"Fira Code\", \"editor.fontSize\": 16, \"editor.lineHeight\": 24, \"editor.fontLigatures\": true,","title":"1.5- Configura\u00e7\u00e3o VSCode"},{"location":"1-Clean-Code/5-vscode-config/#15-configuracao-vscode","text":"1.5.1- Baixar o VSCode 1.5.2- Instalar as seguintes extens\u00f5es no VSCode: Prettier , ESLint e TSLint 1.5.3- Instalar as extens\u00f5es e pacotes globalmente com os comando abaixo: npm install -g tslint npm install -g eslint 1.5.4- Usar a configura\u00e7\u00e3o abaixo como configura\u00e7\u00e3o default do VSCode \"files.eol\": \"\\n\", \"editor.insertSpaces\": false, \"editor.renderWhitespace\": \"all\", \"editor.detectIndentation\": false, \"editor.tabSize\": 4, \"editor.renderControlCharacters\": true, \"editor.tabCompletion\": \"on\", \"editor.formatOnSave\": true, \"eslint.enable\": true, \"prettier.semi\": false, \"prettier.printWidth\": 120, \"prettier.useTabs\": true, \"prettier.tabWidth\": 4, \"prettier.singleQuote\": true, \"prettier.jsxBracketSameLine\": true, \"prettier.eslintIntegration\": true, \"prettier.tslintIntegration\": true 1.5.5- Fonte opcional com Ligadures \"terminal.integrated.fontSize\": 14, \"editor.fontFamily\": \"Fira Code\", \"editor.fontSize\": 16, \"editor.lineHeight\": 24, \"editor.fontLigatures\": true,","title":"1.5- Configura\u00e7\u00e3o VSCode"},{"location":"2-Design-Patterns/1-design-patterns/","text":"2.1- Padr\u00f5es de Design Os padr\u00f5es descritos aqui n\u00e3o s\u00e3o os 23 Design Patterns tornados 'cl\u00e1ssicos' pelo livro Design Patterns, Elements of Reusable Object Oriented Software , cuja primeira edi\u00e7\u00e3o data de 1994. Caso tenha interesse, existe um site muito did\u00e1tico sobre eles aqui . Neste cap\u00edtulo, descrevemos padr\u00f5es atualmente adotados no c\u00f3digo BuildBox, organizados nas categorias a seguir. 2.1- Programa - Estrutura de pastas do projeto 2.2- Programa - Configura\u00e7\u00e3o de estilos 2.3- Programa - Roteamento de p\u00e1ginas 2.4- Programa - Menu(s) de navega\u00e7\u00e3o 2.5- Programa - Processamento Ass\u00edncrono 2.6- Programa - Acesso a APIs 2.7- Programa - Tratamento de erros 2.8- Programa - Gerenciamento de State 2.9- Programa - Persist\u00eancia no Client 2.10- Programa - Autentica\u00e7\u00e3o 2.11- Componentes - Coes\u00e3o e Reuso 2.12- Componentes - Princ\u00edpios SOLID 2.13- Componentes - Controller/View 2.14- Componentes - Formul\u00e1rios 2.15- Componentes - Hooks","title":"2.1- Padr\u00f5es de Design"},{"location":"2-Design-Patterns/1-design-patterns/#21-padroes-de-design","text":"Os padr\u00f5es descritos aqui n\u00e3o s\u00e3o os 23 Design Patterns tornados 'cl\u00e1ssicos' pelo livro Design Patterns, Elements of Reusable Object Oriented Software , cuja primeira edi\u00e7\u00e3o data de 1994. Caso tenha interesse, existe um site muito did\u00e1tico sobre eles aqui . Neste cap\u00edtulo, descrevemos padr\u00f5es atualmente adotados no c\u00f3digo BuildBox, organizados nas categorias a seguir. 2.1- Programa - Estrutura de pastas do projeto 2.2- Programa - Configura\u00e7\u00e3o de estilos 2.3- Programa - Roteamento de p\u00e1ginas 2.4- Programa - Menu(s) de navega\u00e7\u00e3o 2.5- Programa - Processamento Ass\u00edncrono 2.6- Programa - Acesso a APIs 2.7- Programa - Tratamento de erros 2.8- Programa - Gerenciamento de State 2.9- Programa - Persist\u00eancia no Client 2.10- Programa - Autentica\u00e7\u00e3o 2.11- Componentes - Coes\u00e3o e Reuso 2.12- Componentes - Princ\u00edpios SOLID 2.13- Componentes - Controller/View 2.14- Componentes - Formul\u00e1rios 2.15- Componentes - Hooks","title":"2.1- Padr\u00f5es de Design"},{"location":"2-Design-Patterns/2-folder-structure/","text":"2.2- Estrutura de Pastas do Projeto Todos os projetos devem procurar seguir a estrutura de folders descrita a seguir. Na pasta principal do projeto, cujo nome \u00e9 o nome do projeto, ou uma abrevia\u00e7\u00e3o deste nome, tem-se o seguinte conte\u00fado: Pasta/Arquivo Conte\u00fado .husky .vscode node_modules Pasta gerenciada automaticamente pelo pacote npm . N\u00e3o deve ser alterada, manualmente. public Pasta onde ficam os arquivos est\u00e1ticos b\u00e1sicos necess\u00e1rios para exibi\u00e7\u00e3o do aplicativo no navegador cliente, incluindo o arquivo index.html . Os demais arquivos est\u00e1ticos s\u00e3o mantidos na pasta /src/assets . src Pasta onde fica o c\u00f3digo do aplicativo, descrita na se\u00e7\u00e3o abaixo. .editorconfig .gitignore Arquivo para configura\u00e7\u00e3o dos arquivos e pastas, que n\u00e3o devem ser armazenados remotamente pelo gerenciador de vers\u00f5es Git . .prettier Arquivo de configura\u00e7\u00f5es do plugin prettier . .bitbucket-pipelines.yml Configura\u00e7\u00f5es para execu\u00e7\u00e3o dos pipelines de deploy no ambiente de dev . Mantido pela equipe DevOps . lint-staged.js package.json Arquivo que controla quais bibliotecas devem ser instaladas pelo comando npm install package-lock.json Arquivo utilizado pelo npm , em conjunto com o arquivo package.json , cuja fun\u00e7\u00e3o \u00e9 impedir que o npm instale vers\u00f5es posteriores \u00e0s que constam nele, visando assim reduzir problemas de compatibilidade entre as vers\u00f5es das bibliotecas e o pr\u00f3prio node.js . tsconfig.json Arquivo de configura\u00e7\u00f5es do TypeScript , no projeto. yarn.lock Similar ao arquivo package-lock.json, se estiver sendo usado o pacote yarn , em lugar do npm . Conte\u00fado da pasta /src Na pasta '/src' deve-se procurar seguir os nomes de arquivos e sub-folders vistos na figura abaixo Pasta/Arquivo Conte\u00fado assets Todos os \u00edcones, imagens, \u00e1udios, etc. est\u00e1ticos a serem exibidos nas diversas telas e componentes do sistema. components Todos os componentes do aplicativo, incluindo modais, que n\u00e3o s\u00e3o telas do sistema. context Todos os componentes que prov\u00eam contexto no aplicativo. hooks Todos os componentes do tipo Hook . mocks Todos os componentes ou estruturas com dados mocados. routes O componente Router e todo o c\u00f3digo que implementa o roteamento e navega\u00e7\u00e3o entre p\u00e1ginas, no aplicativo. services Arquivos que implementam servi\u00e7os de acesso a APIs, backend, bancos de dados, servi\u00e7os de storage, etc., cujas fun\u00e7\u00f5es, s\u00e3o, normalmente, chamadas pelas fun\u00e7\u00f5es (m\u00e9todos) dos componentes declarados na pasta components ou na pasta views . store C\u00f3digo que implementa o gerenciamento de state usando react-redux . styles C\u00f3digo que define os temas e estilos padr\u00e3o do aplicativo. types Declara\u00e7\u00f5es das interfaces e tipos typescript usadas no aplicativo. utils Fun\u00e7\u00f5es gen\u00e9ricas e auxiliares para a implementa\u00e7\u00e3o do aplicativo. views Todos os componentes que s\u00e3o telas do aplicativo. App.tsx Este arquivo declara o componente raiz do aplicativo, sempre chamado de App , o qual inicia a renderiza\u00e7\u00e3o do componente Routes , que por sua vez, controla a renderiza\u00e7\u00e3o das demais telas do sistema. A se\u00e7\u00e3o 2.3- Programa - Roteamento de p\u00e1ginas apresenta mais detalhes sobre o funcionamento destes componentes. index.tsx Este arquivo \u00e9 gerado automaticamente pelo script create-react-app , \u00e9 padr\u00e3o em todos os frontends e, basicamente, \u00e9 usado para vincular o componente React raiz, do aplicativo, ao elemento HTML que apresenta o conte\u00fado da p\u00e1gina de entrada do aplicativo. Como padr\u00e3o, sempre chamamos o componente React raiz de 'App' e o elemento HTML, que apresenta o conte\u00fado da p\u00e1gina index.html, de 'root', como se observa na figura acima. Al\u00e9m disso, o arquivo 'index.html', \u00e9 sempre criado na pasta '/public' pelo script create-react-app .","title":"2.2- Estrutura de Pastas do Projeto"},{"location":"2-Design-Patterns/2-folder-structure/#22-estrutura-de-pastas-do-projeto","text":"Todos os projetos devem procurar seguir a estrutura de folders descrita a seguir. Na pasta principal do projeto, cujo nome \u00e9 o nome do projeto, ou uma abrevia\u00e7\u00e3o deste nome, tem-se o seguinte conte\u00fado: Pasta/Arquivo Conte\u00fado .husky .vscode node_modules Pasta gerenciada automaticamente pelo pacote npm . N\u00e3o deve ser alterada, manualmente. public Pasta onde ficam os arquivos est\u00e1ticos b\u00e1sicos necess\u00e1rios para exibi\u00e7\u00e3o do aplicativo no navegador cliente, incluindo o arquivo index.html . Os demais arquivos est\u00e1ticos s\u00e3o mantidos na pasta /src/assets . src Pasta onde fica o c\u00f3digo do aplicativo, descrita na se\u00e7\u00e3o abaixo. .editorconfig .gitignore Arquivo para configura\u00e7\u00e3o dos arquivos e pastas, que n\u00e3o devem ser armazenados remotamente pelo gerenciador de vers\u00f5es Git . .prettier Arquivo de configura\u00e7\u00f5es do plugin prettier . .bitbucket-pipelines.yml Configura\u00e7\u00f5es para execu\u00e7\u00e3o dos pipelines de deploy no ambiente de dev . Mantido pela equipe DevOps . lint-staged.js package.json Arquivo que controla quais bibliotecas devem ser instaladas pelo comando npm install package-lock.json Arquivo utilizado pelo npm , em conjunto com o arquivo package.json , cuja fun\u00e7\u00e3o \u00e9 impedir que o npm instale vers\u00f5es posteriores \u00e0s que constam nele, visando assim reduzir problemas de compatibilidade entre as vers\u00f5es das bibliotecas e o pr\u00f3prio node.js . tsconfig.json Arquivo de configura\u00e7\u00f5es do TypeScript , no projeto. yarn.lock Similar ao arquivo package-lock.json, se estiver sendo usado o pacote yarn , em lugar do npm .","title":"2.2- Estrutura de Pastas do Projeto"},{"location":"2-Design-Patterns/2-folder-structure/#conteudo-da-pasta-src","text":"Na pasta '/src' deve-se procurar seguir os nomes de arquivos e sub-folders vistos na figura abaixo Pasta/Arquivo Conte\u00fado assets Todos os \u00edcones, imagens, \u00e1udios, etc. est\u00e1ticos a serem exibidos nas diversas telas e componentes do sistema. components Todos os componentes do aplicativo, incluindo modais, que n\u00e3o s\u00e3o telas do sistema. context Todos os componentes que prov\u00eam contexto no aplicativo. hooks Todos os componentes do tipo Hook . mocks Todos os componentes ou estruturas com dados mocados. routes O componente Router e todo o c\u00f3digo que implementa o roteamento e navega\u00e7\u00e3o entre p\u00e1ginas, no aplicativo. services Arquivos que implementam servi\u00e7os de acesso a APIs, backend, bancos de dados, servi\u00e7os de storage, etc., cujas fun\u00e7\u00f5es, s\u00e3o, normalmente, chamadas pelas fun\u00e7\u00f5es (m\u00e9todos) dos componentes declarados na pasta components ou na pasta views . store C\u00f3digo que implementa o gerenciamento de state usando react-redux . styles C\u00f3digo que define os temas e estilos padr\u00e3o do aplicativo. types Declara\u00e7\u00f5es das interfaces e tipos typescript usadas no aplicativo. utils Fun\u00e7\u00f5es gen\u00e9ricas e auxiliares para a implementa\u00e7\u00e3o do aplicativo. views Todos os componentes que s\u00e3o telas do aplicativo. App.tsx Este arquivo declara o componente raiz do aplicativo, sempre chamado de App , o qual inicia a renderiza\u00e7\u00e3o do componente Routes , que por sua vez, controla a renderiza\u00e7\u00e3o das demais telas do sistema. A se\u00e7\u00e3o 2.3- Programa - Roteamento de p\u00e1ginas apresenta mais detalhes sobre o funcionamento destes componentes. index.tsx Este arquivo \u00e9 gerado automaticamente pelo script create-react-app , \u00e9 padr\u00e3o em todos os frontends e, basicamente, \u00e9 usado para vincular o componente React raiz, do aplicativo, ao elemento HTML que apresenta o conte\u00fado da p\u00e1gina de entrada do aplicativo. Como padr\u00e3o, sempre chamamos o componente React raiz de 'App' e o elemento HTML, que apresenta o conte\u00fado da p\u00e1gina index.html, de 'root', como se observa na figura acima. Al\u00e9m disso, o arquivo 'index.html', \u00e9 sempre criado na pasta '/public' pelo script create-react-app .","title":"Conte\u00fado da pasta /src"},{"location":"2-Design-Patterns/3-page-routing/","text":"2.3- Roteamento de p\u00e1ginas do Aplicativo O controle de navega\u00e7\u00e3o entre as p\u00e1ginas se inicia no elemento HTML raiz do aplicativo, inicializado no arquivo index.tsx , conforme explicado na p\u00e1gina que apresenta a estrutura de pastas, aqui Estrutura de Pastas do Projeto . Ap\u00f3s as inicializa\u00e7\u00f5es necess\u00e1rias, a renderiza\u00e7\u00e3o do elemento raiz (m\u00e9todo render(...) abaixo) passa o controle do fluxo do aplicativo para o componente raiz do aplicativo, chamado App . A seguir, descrevemos o componente App . Componente App Este componente \u00e9 declarado no arquivo App.tsx , sendo o componente raiz do aplicativo, que deve ser, sempre, chamado de 'App'. O 'cora\u00e7\u00e3o' deste componente est\u00e1 no return de renderiza\u00e7\u00e3o, onde o componente que controla a renderiza\u00e7\u00e3o de todas as p\u00e1ginas e sub-componentes, chamado por padr\u00e3o de 'Router', \u00e9 envolto ( wrapped ) por v\u00e1rios contextos React que ser\u00e3o disponibilizados a todos os componentes do aplicativo. SoundProvider \u00e9 um componente provedor de contexto, desenvolvido pela BuildBox no arquivo 'src/context/SoundProvider.tsx', que utiliza a biblioteca use-sound , e basicamente prov\u00ea um hook capaz de reproduzir arquivos .mp3 . Provider \u00e9 o componente da biblioteca redux que permite o armazenamento de informa\u00e7\u00f5es, tais como informa\u00e7\u00f5es do cliente ou transa\u00e7\u00e3o, etc., de forma estruturada na m\u00e1quina cliente. PersistGate \u00e9 o componente, da biblioteca redux-persist que permite a persist\u00eancia dos dados salvos no store redux. ThemeProvider \u00e9 um componente, da biblioteca styled-components , que permite definir um tema default para os aplicativos. MuiThemeProvider \u00e9 um segundo componente provedor de tema, que permite addicionar mais informa\u00e7\u00f5es default ao tema default nos aplicativos, neste caso usando os recursos da biblioteca MUI . QueryClient e QueryClientProvider s\u00e3o componentes, da biblioteca react-query , que padronizam e facilitam a codifica\u00e7\u00e3o da comunica\u00e7\u00e3o com API externas. Al\u00e9m dos contextos acima, temos: Um styled-component, chamado GlobalStyle , mantido no arquivo 'src/styles/GlobalStyle.ts', que define o .css geral default de todas as p\u00e1ginas. Um componente chamado ToastContainer , parte da biblioteca react-toastify , usado para exibi\u00e7\u00e3o de mensagens para o usu\u00e1rio. Componente Routes O c\u00f3digo deste componente est\u00e1 na pasta /src/routes , sendo o componente onde s\u00e3o declaradas todas as p\u00e1ginas e rotas do aplicativo. Arquivo routes.ts O arquivo routes declara um array de objetos do tipo IRoute , que servem para configurar as seguintes informa\u00e7\u00f5es de cada p\u00e1gina do aplicativo: export interface IRoute { element: string | FunctionComponent<{}> | ComponentClass<{}> title?: string path: string secure?: boolean fullPage?: boolean layout?: boolean menu?: boolean accessType?: UserTypesEnum[] children?: IRoute[] } Esta interface IRoute est\u00e1 definida no arquivo /src/routes/types . Onde: element \u00e9 uma refer\u00eancia para o componente React que implemente a p\u00e1gina. title \u00e9 uma string com o t\u00edtulo da p\u00e1gina. path \u00e9 o caminho da p\u00e1gina no servidor. secure \u00e9 uma vari\u00e1vel booleana, onde true indica que a p\u00e1gina s\u00f3 pode ser acessada com por um usu\u00e1rio logado no aplicativo, ou seja que tenha sido autenticado. fullPage , vari\u00e1vel cujo uso foi descontinuado. layout , vari\u00e1vel booleana onde true indica que deve ser usado um layout externo, com Header e Menu Lateral, definidos no componente Layout , na pasta /src/components/Layout , em torno do componente da p\u00e1gina. No caso do valor da vari\u00e1vel ser false , ou undefined, ser\u00e1 usado apenas o layout definido pelo componente da p\u00e1gina. menu , vari\u00e1vel booleana cujo uso foi descontinuado. accessType , \u00e9 um array que cont\u00e9m todos os perfis de usu\u00e1rio que podem acessar a p\u00e1gina. Se Se esta vari\u00e1vel contiver um array de valores de perfil, somente os usu\u00e1rios que tenham um desses perfis poder\u00e3o acess\u00e1-la. children \u00e9 uma vari\u00e1vel que cont\u00e9m a refer\u00eancia para o componente React que implementa a p\u00e1gina. Os tipos de perfis de usu\u00e1rios s\u00e3o arbitr\u00e1rios por aplicativo e devem ser definidos como um Enum no arquivo /src/routes/types.ts , juntamente com a defini\u00e7\u00e3o da interface IRoute . Um exemplo: Arquivo index.tsx O arquivo index.tsx : - implementa o mecanismo gen\u00e9rico que chama a renderiza\u00e7\u00e3o de todas as p\u00e1ginas configuradas no arquivo routes.ts - controla o acesso a cada p\u00e1gina, por meio da fun\u00e7\u00e3o handlePermission(...) - redireciona o fluxo para a p\u00e1gina de Login, caso o usu\u00e1rio ainda n\u00e3o esteja logado (autenticado). - trata redirecionamentos espec\u00edficos, no caso de Erro 4, retornado pelo backend, atrav\u00e9s do componente Redirect , implementado no arquivo /src/routes/redirect.tsx .","title":"2.3- Roteamento de p\u00e1ginas do Aplicativo"},{"location":"2-Design-Patterns/3-page-routing/#23-roteamento-de-paginas-do-aplicativo","text":"O controle de navega\u00e7\u00e3o entre as p\u00e1ginas se inicia no elemento HTML raiz do aplicativo, inicializado no arquivo index.tsx , conforme explicado na p\u00e1gina que apresenta a estrutura de pastas, aqui Estrutura de Pastas do Projeto . Ap\u00f3s as inicializa\u00e7\u00f5es necess\u00e1rias, a renderiza\u00e7\u00e3o do elemento raiz (m\u00e9todo render(...) abaixo) passa o controle do fluxo do aplicativo para o componente raiz do aplicativo, chamado App . A seguir, descrevemos o componente App .","title":"2.3- Roteamento de p\u00e1ginas do Aplicativo"},{"location":"2-Design-Patterns/3-page-routing/#componente-app","text":"Este componente \u00e9 declarado no arquivo App.tsx , sendo o componente raiz do aplicativo, que deve ser, sempre, chamado de 'App'. O 'cora\u00e7\u00e3o' deste componente est\u00e1 no return de renderiza\u00e7\u00e3o, onde o componente que controla a renderiza\u00e7\u00e3o de todas as p\u00e1ginas e sub-componentes, chamado por padr\u00e3o de 'Router', \u00e9 envolto ( wrapped ) por v\u00e1rios contextos React que ser\u00e3o disponibilizados a todos os componentes do aplicativo. SoundProvider \u00e9 um componente provedor de contexto, desenvolvido pela BuildBox no arquivo 'src/context/SoundProvider.tsx', que utiliza a biblioteca use-sound , e basicamente prov\u00ea um hook capaz de reproduzir arquivos .mp3 . Provider \u00e9 o componente da biblioteca redux que permite o armazenamento de informa\u00e7\u00f5es, tais como informa\u00e7\u00f5es do cliente ou transa\u00e7\u00e3o, etc., de forma estruturada na m\u00e1quina cliente. PersistGate \u00e9 o componente, da biblioteca redux-persist que permite a persist\u00eancia dos dados salvos no store redux. ThemeProvider \u00e9 um componente, da biblioteca styled-components , que permite definir um tema default para os aplicativos. MuiThemeProvider \u00e9 um segundo componente provedor de tema, que permite addicionar mais informa\u00e7\u00f5es default ao tema default nos aplicativos, neste caso usando os recursos da biblioteca MUI . QueryClient e QueryClientProvider s\u00e3o componentes, da biblioteca react-query , que padronizam e facilitam a codifica\u00e7\u00e3o da comunica\u00e7\u00e3o com API externas. Al\u00e9m dos contextos acima, temos: Um styled-component, chamado GlobalStyle , mantido no arquivo 'src/styles/GlobalStyle.ts', que define o .css geral default de todas as p\u00e1ginas. Um componente chamado ToastContainer , parte da biblioteca react-toastify , usado para exibi\u00e7\u00e3o de mensagens para o usu\u00e1rio.","title":"Componente App"},{"location":"2-Design-Patterns/3-page-routing/#componente-routes","text":"O c\u00f3digo deste componente est\u00e1 na pasta /src/routes , sendo o componente onde s\u00e3o declaradas todas as p\u00e1ginas e rotas do aplicativo.","title":"Componente Routes"},{"location":"2-Design-Patterns/3-page-routing/#arquivo-routests","text":"O arquivo routes declara um array de objetos do tipo IRoute , que servem para configurar as seguintes informa\u00e7\u00f5es de cada p\u00e1gina do aplicativo: export interface IRoute { element: string | FunctionComponent<{}> | ComponentClass<{}> title?: string path: string secure?: boolean fullPage?: boolean layout?: boolean menu?: boolean accessType?: UserTypesEnum[] children?: IRoute[] } Esta interface IRoute est\u00e1 definida no arquivo /src/routes/types . Onde: element \u00e9 uma refer\u00eancia para o componente React que implemente a p\u00e1gina. title \u00e9 uma string com o t\u00edtulo da p\u00e1gina. path \u00e9 o caminho da p\u00e1gina no servidor. secure \u00e9 uma vari\u00e1vel booleana, onde true indica que a p\u00e1gina s\u00f3 pode ser acessada com por um usu\u00e1rio logado no aplicativo, ou seja que tenha sido autenticado. fullPage , vari\u00e1vel cujo uso foi descontinuado. layout , vari\u00e1vel booleana onde true indica que deve ser usado um layout externo, com Header e Menu Lateral, definidos no componente Layout , na pasta /src/components/Layout , em torno do componente da p\u00e1gina. No caso do valor da vari\u00e1vel ser false , ou undefined, ser\u00e1 usado apenas o layout definido pelo componente da p\u00e1gina. menu , vari\u00e1vel booleana cujo uso foi descontinuado. accessType , \u00e9 um array que cont\u00e9m todos os perfis de usu\u00e1rio que podem acessar a p\u00e1gina. Se Se esta vari\u00e1vel contiver um array de valores de perfil, somente os usu\u00e1rios que tenham um desses perfis poder\u00e3o acess\u00e1-la. children \u00e9 uma vari\u00e1vel que cont\u00e9m a refer\u00eancia para o componente React que implementa a p\u00e1gina. Os tipos de perfis de usu\u00e1rios s\u00e3o arbitr\u00e1rios por aplicativo e devem ser definidos como um Enum no arquivo /src/routes/types.ts , juntamente com a defini\u00e7\u00e3o da interface IRoute . Um exemplo:","title":"Arquivo routes.ts"},{"location":"2-Design-Patterns/3-page-routing/#arquivo-indextsx","text":"O arquivo index.tsx : - implementa o mecanismo gen\u00e9rico que chama a renderiza\u00e7\u00e3o de todas as p\u00e1ginas configuradas no arquivo routes.ts - controla o acesso a cada p\u00e1gina, por meio da fun\u00e7\u00e3o handlePermission(...) - redireciona o fluxo para a p\u00e1gina de Login, caso o usu\u00e1rio ainda n\u00e3o esteja logado (autenticado). - trata redirecionamentos espec\u00edficos, no caso de Erro 4, retornado pelo backend, atrav\u00e9s do componente Redirect , implementado no arquivo /src/routes/redirect.tsx .","title":"Arquivo index.tsx"},{"location":"2-Design-Patterns/4-navigation-menu/","text":"2.4- Header e Menu de navega\u00e7\u00e3o do Aplicativo Al\u00e9m do controle de navega\u00e7\u00e3o, visto na se\u00e7\u00e3o Roteamento de p\u00e1ginas , existe um componente padr\u00e3o, chamado Layout , que produz a exibi\u00e7\u00e3o de um Header, na parte superior da tela, e de um Menu de Navega\u00e7\u00e3o lateral, no lado esquerdo da tela, o qual tamb\u00e9m participa do controle de navega\u00e7\u00e3o de p\u00e1ginas padr\u00e3o, do aplicativo. Este componente \u00e9 definido pelo c\u00f3digo mantido na pasta /src/components/layout . O componente principal \u00e9, como vimos, o componente Layout , definido no arquivo /src/components/Layout/index.tsx . Essencialmente, este componente, renderiza os componentes vistos na figura abaixo. Header , definido na pasta /src/components/Layout/components/Header , cuja fun\u00e7\u00e3o \u00e9 exibir na parte superior da tela o \u00edcone do aplicativo e informa\u00e7\u00f5es do usu\u00e1rio logado, avatar, nome e outras, que estejam salvas no store redux do aplicativo. SideNav , definido na pasta /src/components/Layout/components/SideNav , cuja fun\u00e7\u00e3o \u00e9 exibir na lateral esquerda da tela um menu que d\u00e1 acesso a um grupo espec\u00edfico de telas do aplicativo. Container , como o nome indica, o componente Container \u00e9 apenas um recipiente do tipo styled component para envolver o componente React que houver sido definido para a tela corrente, passado para o componente Layout no par\u00e2metro children . A propriedade headerFilterProps , passada para o componente Header \u00e9 definida com o seguinte objeto Este objeto, configura: Se o menu lateral est\u00e1 vis\u00edvel, ou n\u00e3o, atrav\u00e9s da propriedade isOpen . Como e quando o menu lateral ser\u00e1 exibido ou escondido, em fun\u00e7\u00e3o do comportamento da fun\u00e7\u00e3o handleOpenSideNav , que no caso padr\u00e3o, \u00e9 definida assim: Os dados padr\u00e3o do usu\u00e1rio, o nome e seu avatar, atrav\u00e9s da propriedade user . Dados adicionais salvos no store redux, atrav\u00e9s da propriedade store . Por fim, a propriedade sideNavProps , passada para o componente SideNav , determina quais p\u00e1ginas do aplicativo (definidas no arquivo /src/routes/routes.ts ) ser\u00e3o exibidas como links no menu lateral, em fun\u00e7\u00e3o da propriedade menu ser true ou false , e faz tamb\u00e9m o controle de acesso do usu\u00e1rio logado a estas telas, em fun\u00e7\u00e3o dos perfis listados no usu\u00e1rio corrente e dos perfis listados na propriedade route.userType da respectiva p\u00e1gina. Vide c\u00f3digo abaixo.","title":"2.4- Header e Menu de navega\u00e7\u00e3o do Aplicativo"},{"location":"2-Design-Patterns/4-navigation-menu/#24-header-e-menu-de-navegacao-do-aplicativo","text":"Al\u00e9m do controle de navega\u00e7\u00e3o, visto na se\u00e7\u00e3o Roteamento de p\u00e1ginas , existe um componente padr\u00e3o, chamado Layout , que produz a exibi\u00e7\u00e3o de um Header, na parte superior da tela, e de um Menu de Navega\u00e7\u00e3o lateral, no lado esquerdo da tela, o qual tamb\u00e9m participa do controle de navega\u00e7\u00e3o de p\u00e1ginas padr\u00e3o, do aplicativo. Este componente \u00e9 definido pelo c\u00f3digo mantido na pasta /src/components/layout . O componente principal \u00e9, como vimos, o componente Layout , definido no arquivo /src/components/Layout/index.tsx . Essencialmente, este componente, renderiza os componentes vistos na figura abaixo. Header , definido na pasta /src/components/Layout/components/Header , cuja fun\u00e7\u00e3o \u00e9 exibir na parte superior da tela o \u00edcone do aplicativo e informa\u00e7\u00f5es do usu\u00e1rio logado, avatar, nome e outras, que estejam salvas no store redux do aplicativo. SideNav , definido na pasta /src/components/Layout/components/SideNav , cuja fun\u00e7\u00e3o \u00e9 exibir na lateral esquerda da tela um menu que d\u00e1 acesso a um grupo espec\u00edfico de telas do aplicativo. Container , como o nome indica, o componente Container \u00e9 apenas um recipiente do tipo styled component para envolver o componente React que houver sido definido para a tela corrente, passado para o componente Layout no par\u00e2metro children . A propriedade headerFilterProps , passada para o componente Header \u00e9 definida com o seguinte objeto Este objeto, configura: Se o menu lateral est\u00e1 vis\u00edvel, ou n\u00e3o, atrav\u00e9s da propriedade isOpen . Como e quando o menu lateral ser\u00e1 exibido ou escondido, em fun\u00e7\u00e3o do comportamento da fun\u00e7\u00e3o handleOpenSideNav , que no caso padr\u00e3o, \u00e9 definida assim: Os dados padr\u00e3o do usu\u00e1rio, o nome e seu avatar, atrav\u00e9s da propriedade user . Dados adicionais salvos no store redux, atrav\u00e9s da propriedade store . Por fim, a propriedade sideNavProps , passada para o componente SideNav , determina quais p\u00e1ginas do aplicativo (definidas no arquivo /src/routes/routes.ts ) ser\u00e3o exibidas como links no menu lateral, em fun\u00e7\u00e3o da propriedade menu ser true ou false , e faz tamb\u00e9m o controle de acesso do usu\u00e1rio logado a estas telas, em fun\u00e7\u00e3o dos perfis listados no usu\u00e1rio corrente e dos perfis listados na propriedade route.userType da respectiva p\u00e1gina. Vide c\u00f3digo abaixo.","title":"2.4- Header e Menu de navega\u00e7\u00e3o do Aplicativo"},{"location":"2-Design-Patterns/5-asynchronous-processing/","text":"2.5- Processamento Ass\u00edncrono Sempre que for necess\u00e1rio aguardar um processamento ass\u00edncrono, cujo tempo de execu\u00e7\u00e3o n\u00e3o pode ser controlado pelo aplicativo, devem ser usadas as keywords async e await , de forma a garantir que o aplicativo n\u00e3o trave o loop de eventos do engine javascript (o que poderia produzir a experi\u00eancia de travamento no navegador, para o usu\u00e1rio, no caso de frontend). A mesma regra deve ser seguida no backend, usando node.js ou em dispositivos mobile . Exemplos deste tipo de situa\u00e7\u00e3o, em um frontend, s\u00e3o: - Acesso ao backend - Acesso a uma API externa, por exemplo, Google ou AWS Storage. - Acesso direto a um Banco de Dados, via nbiblioteca SDK ou via uma API - Execu\u00e7\u00e3o de qualquer fun\u00e7\u00e3o que retorne uma Promessa (Promise) Vamos fornecer alguns exemplos de como fazer isso. Acesso ao backend: Neste caso, a keyword await precisa ser usada antes da fun\u00e7\u00e3o axiosInstance.patch(...) , para garantir que a fun\u00e7\u00e3o s\u00f3 retorna quando os dados em response.data estiverem prontos. Enquanto isso n\u00e3o ocorre, o engine JavaScript passa o controle do fluxo para o loop de eventos que ir\u00e1 determinar que outras threads do aplicativo ou de outros sistemas, devem ser executados, impedindo assim, que o seu navegador trave. Acesso a uma API externa: Similar ao exemplo anterior. Um ponto importante, aqui, diz respeito \u00e0 chamada deste tipo de fun\u00e7\u00e3o nas fun\u00e7\u00f5es de n\u00edvel mais elevado. \u00c9 importante procurar usar sempre as keywords async e await , ao inv\u00e9s de callbacks ou de chaining com o m\u00e9todo .then(...) . Neste caso, a op\u00e7\u00e3o abaixo \u00e9 a recomendada, em rela\u00e7\u00e3o \u00e0 vers\u00e3o chained, abaixo","title":"2.5- Processamento Ass\u00edncrono"},{"location":"2-Design-Patterns/5-asynchronous-processing/#25-processamento-assincrono","text":"Sempre que for necess\u00e1rio aguardar um processamento ass\u00edncrono, cujo tempo de execu\u00e7\u00e3o n\u00e3o pode ser controlado pelo aplicativo, devem ser usadas as keywords async e await , de forma a garantir que o aplicativo n\u00e3o trave o loop de eventos do engine javascript (o que poderia produzir a experi\u00eancia de travamento no navegador, para o usu\u00e1rio, no caso de frontend). A mesma regra deve ser seguida no backend, usando node.js ou em dispositivos mobile . Exemplos deste tipo de situa\u00e7\u00e3o, em um frontend, s\u00e3o: - Acesso ao backend - Acesso a uma API externa, por exemplo, Google ou AWS Storage. - Acesso direto a um Banco de Dados, via nbiblioteca SDK ou via uma API - Execu\u00e7\u00e3o de qualquer fun\u00e7\u00e3o que retorne uma Promessa (Promise) Vamos fornecer alguns exemplos de como fazer isso. Acesso ao backend: Neste caso, a keyword await precisa ser usada antes da fun\u00e7\u00e3o axiosInstance.patch(...) , para garantir que a fun\u00e7\u00e3o s\u00f3 retorna quando os dados em response.data estiverem prontos. Enquanto isso n\u00e3o ocorre, o engine JavaScript passa o controle do fluxo para o loop de eventos que ir\u00e1 determinar que outras threads do aplicativo ou de outros sistemas, devem ser executados, impedindo assim, que o seu navegador trave. Acesso a uma API externa: Similar ao exemplo anterior. Um ponto importante, aqui, diz respeito \u00e0 chamada deste tipo de fun\u00e7\u00e3o nas fun\u00e7\u00f5es de n\u00edvel mais elevado. \u00c9 importante procurar usar sempre as keywords async e await , ao inv\u00e9s de callbacks ou de chaining com o m\u00e9todo .then(...) . Neste caso, a op\u00e7\u00e3o abaixo \u00e9 a recomendada, em rela\u00e7\u00e3o \u00e0 vers\u00e3o chained, abaixo","title":"2.5- Processamento Ass\u00edncrono"},{"location":"2-Design-Patterns/6-api-access/","text":"2.6- Acesso a APIs externas O acesso a APIs externas \u00e9 feito atraves da biblioteca axios , utilizando o objeto AxiosInstance , conforme o padr\u00e3o mostrado no arquivo /src/services/axiosInstance.ts , exibido abaixo. Basicamente, este arquivo cria um objeto axiosInstance , configurando o dom\u00ednio e timeout para todas as requests. Depois, \u00e9 criada uma fun\u00e7\u00e3o an\u00f4nima para interceptar cada request (request) => {...} O papel desta fun\u00e7\u00e3o \u00e9 injetar em cada request as informa\u00e7\u00f5es de autentica\u00e7\u00e3o no campo Authorization do Header , da respectiva request. Existe tamb\u00e9m uma fun\u00e7\u00e3o an\u00f4nima que direciona os erros de comunica\u00e7\u00e3o para serem tratados pela fun\u00e7\u00e3o handleError(err) , definida no arquivo /src/utils/handleError.ts , a qual ser\u00e1 explicada na se\u00e7\u00e3o 2.7- Tratamento de Erros . Al\u00e9m disso, este arquivo define, tamb\u00e9m, duas outras fun\u00e7\u00f5es an\u00f4nimas, que s\u00e3o executados na chegada de uma resposta da API, mostradas abaixo. A fun\u00e7\u00e3o que intercepta a resposta \u00e9 usada para fins de depura\u00e7\u00e3o, quando o sistema est\u00e1 em ambiente de desenvolvimento. A fun\u00e7\u00e3o de tratamento de erros trabalha de forma similar \u00e0 situa\u00e7\u00e3o de envio de request, mostrada anteriormente.","title":"2.6- Acesso a APIs externas"},{"location":"2-Design-Patterns/6-api-access/#26-acesso-a-apis-externas","text":"O acesso a APIs externas \u00e9 feito atraves da biblioteca axios , utilizando o objeto AxiosInstance , conforme o padr\u00e3o mostrado no arquivo /src/services/axiosInstance.ts , exibido abaixo. Basicamente, este arquivo cria um objeto axiosInstance , configurando o dom\u00ednio e timeout para todas as requests. Depois, \u00e9 criada uma fun\u00e7\u00e3o an\u00f4nima para interceptar cada request (request) => {...} O papel desta fun\u00e7\u00e3o \u00e9 injetar em cada request as informa\u00e7\u00f5es de autentica\u00e7\u00e3o no campo Authorization do Header , da respectiva request. Existe tamb\u00e9m uma fun\u00e7\u00e3o an\u00f4nima que direciona os erros de comunica\u00e7\u00e3o para serem tratados pela fun\u00e7\u00e3o handleError(err) , definida no arquivo /src/utils/handleError.ts , a qual ser\u00e1 explicada na se\u00e7\u00e3o 2.7- Tratamento de Erros . Al\u00e9m disso, este arquivo define, tamb\u00e9m, duas outras fun\u00e7\u00f5es an\u00f4nimas, que s\u00e3o executados na chegada de uma resposta da API, mostradas abaixo. A fun\u00e7\u00e3o que intercepta a resposta \u00e9 usada para fins de depura\u00e7\u00e3o, quando o sistema est\u00e1 em ambiente de desenvolvimento. A fun\u00e7\u00e3o de tratamento de erros trabalha de forma similar \u00e0 situa\u00e7\u00e3o de envio de request, mostrada anteriormente.","title":"2.6- Acesso a APIs externas"},{"location":"2-Design-Patterns/7-error-treatment/","text":"2.7- Tratamento de Erros O escopo desta se\u00e7\u00e3o, atualmente, resume-se a erros ocorridos no acesso a APIs externas. O objetivo por detr\u00e1s deste design \u00e9 concentrar o c\u00f3digo de tratamento de erros em um \u00fanico local, de modo a reduzir inconsist\u00eancias em manuten\u00e7\u00f5es futuras e de modo a deixar todo o c\u00f3digo do aplicativo mais leve, por estar 'limpo' de c\u00f3digo que trata erros. O que foi feito foi, incluir 2 fun\u00e7\u00f5es an\u00f4nimas para tratamento de erros nos interceptadores do objeto axiosInstance , definidas no arquivo /src/service/axiosInstance , conforme explicado na se\u00e7\u00e3o anterior, 2.6- Acesso a APIs externas . Uma fun\u00e7\u00e3o intercepta os erros ocorridos no envio de todas as requests e a outra intercepta os erros ocorridos na chegada de todas as respostas da API. Tais fun\u00e7\u00f5es chamam, ent\u00e3o, a fun\u00e7\u00e3o handleError(err) definida no arquivo /src/utils/handleError.ts . Este design \u00e9 interessante porque torna desnecess\u00e1rio capturar erros, usando as keywords try e catch , nas fun\u00e7\u00f5es de mais alto n\u00edvel, que chamam os m\u00e9todos do objeto axiosInstance , por exemplo, no c\u00f3digo abaixo. Isto acontece, porque tais erros, quando ocorrem, s\u00e3o capturados e tratados antes pela fun\u00e7\u00e3o handleError(...) , como explicado acima. No c\u00f3digo exemplo acima, se a fun\u00e7\u00e3o patchProducts alcan\u00e7ou a linha return response.data isso significa que n\u00e3o ocorreram erros de comunica\u00e7\u00e3o, pois se tivessem ocorrido, j\u00e1 teriam sido capturados e direcionados para a fun\u00e7\u00e3o handleError(...) . Por fim, vamos explicar o funcionamento da fun\u00e7\u00e3o handleError(...) , exibida abaixo. A fun\u00e7\u00e3o handleError(...) recebe como par\u00e2metro o objeto retornado pela resposta do m\u00e9todo utilizado do objeto axiosInstance . Por exemplo, se foi chamado o m\u00e9todo axiosInstance.post , esta fun\u00e7\u00e3o ir\u00e1 receber o objeto de resposta do m\u00e9todo .post . Basicamente, a fun\u00e7\u00e3o verifica se houve um erro de comunica\u00e7\u00e3o 401, que indicaria problemas de autentica\u00e7\u00e3o do usu\u00e1rio na request e, caso tenha recebido esse tipo de erro, for\u00e7a o logout do aplicativo encerrando a sess\u00e3o, chamando para isso a fun\u00e7\u00e3o logout() , definida no arquivo /src/utils/session.ts , reproduzida abaixo. Observe, que o store redux \u00e9 reiniciado, por essa fun\u00e7\u00e3o. No caso de o erro, n\u00e3o ser um problema de autentica\u00e7\u00e3o, a fun\u00e7\u00e3o handleError(...) apenas exibe na tela um objeto do tipo toaster , informando ao usu\u00e1rio o erro ocorrido. Por fim, caso a resposta vinda do backend n\u00e3o contenha status code ou uma message de erro, geralmente por timeout na resposta, handleError(...) exibe o objeto do tipo toaster , informando ao usu\u00e1rio que o servidor est\u00e1 indispon\u00edvel, o que pode indicar problemas no servidor, na internet ou intranet.","title":"2.7- Tratamento de Erros"},{"location":"2-Design-Patterns/7-error-treatment/#27-tratamento-de-erros","text":"O escopo desta se\u00e7\u00e3o, atualmente, resume-se a erros ocorridos no acesso a APIs externas. O objetivo por detr\u00e1s deste design \u00e9 concentrar o c\u00f3digo de tratamento de erros em um \u00fanico local, de modo a reduzir inconsist\u00eancias em manuten\u00e7\u00f5es futuras e de modo a deixar todo o c\u00f3digo do aplicativo mais leve, por estar 'limpo' de c\u00f3digo que trata erros. O que foi feito foi, incluir 2 fun\u00e7\u00f5es an\u00f4nimas para tratamento de erros nos interceptadores do objeto axiosInstance , definidas no arquivo /src/service/axiosInstance , conforme explicado na se\u00e7\u00e3o anterior, 2.6- Acesso a APIs externas . Uma fun\u00e7\u00e3o intercepta os erros ocorridos no envio de todas as requests e a outra intercepta os erros ocorridos na chegada de todas as respostas da API. Tais fun\u00e7\u00f5es chamam, ent\u00e3o, a fun\u00e7\u00e3o handleError(err) definida no arquivo /src/utils/handleError.ts . Este design \u00e9 interessante porque torna desnecess\u00e1rio capturar erros, usando as keywords try e catch , nas fun\u00e7\u00f5es de mais alto n\u00edvel, que chamam os m\u00e9todos do objeto axiosInstance , por exemplo, no c\u00f3digo abaixo. Isto acontece, porque tais erros, quando ocorrem, s\u00e3o capturados e tratados antes pela fun\u00e7\u00e3o handleError(...) , como explicado acima. No c\u00f3digo exemplo acima, se a fun\u00e7\u00e3o patchProducts alcan\u00e7ou a linha return response.data isso significa que n\u00e3o ocorreram erros de comunica\u00e7\u00e3o, pois se tivessem ocorrido, j\u00e1 teriam sido capturados e direcionados para a fun\u00e7\u00e3o handleError(...) . Por fim, vamos explicar o funcionamento da fun\u00e7\u00e3o handleError(...) , exibida abaixo. A fun\u00e7\u00e3o handleError(...) recebe como par\u00e2metro o objeto retornado pela resposta do m\u00e9todo utilizado do objeto axiosInstance . Por exemplo, se foi chamado o m\u00e9todo axiosInstance.post , esta fun\u00e7\u00e3o ir\u00e1 receber o objeto de resposta do m\u00e9todo .post . Basicamente, a fun\u00e7\u00e3o verifica se houve um erro de comunica\u00e7\u00e3o 401, que indicaria problemas de autentica\u00e7\u00e3o do usu\u00e1rio na request e, caso tenha recebido esse tipo de erro, for\u00e7a o logout do aplicativo encerrando a sess\u00e3o, chamando para isso a fun\u00e7\u00e3o logout() , definida no arquivo /src/utils/session.ts , reproduzida abaixo. Observe, que o store redux \u00e9 reiniciado, por essa fun\u00e7\u00e3o. No caso de o erro, n\u00e3o ser um problema de autentica\u00e7\u00e3o, a fun\u00e7\u00e3o handleError(...) apenas exibe na tela um objeto do tipo toaster , informando ao usu\u00e1rio o erro ocorrido. Por fim, caso a resposta vinda do backend n\u00e3o contenha status code ou uma message de erro, geralmente por timeout na resposta, handleError(...) exibe o objeto do tipo toaster , informando ao usu\u00e1rio que o servidor est\u00e1 indispon\u00edvel, o que pode indicar problemas no servidor, na internet ou intranet.","title":"2.7- Tratamento de Erros"},{"location":"2-Design-Patterns/8-state-management/","text":"2.8- Gerenciamento de State O que \u00e9 Gerenciamento de state ? O State \u00e9 um conjunto de informa\u00e7\u00f5es que s\u00e3o importantes para todo o aplicativo, no frontend ( Client ), e que precisam ser preservadas na mem\u00f3ria desse cliente. Tipicamente, o state \u00e9 constitu\u00eddo por informa\u00e7\u00f5es do usu\u00e1rio logado, tais como, nome, e-mail, avatar, token, etc., mas pode incluir outros tipos de informa\u00e7\u00e3o. O Gerenciamento de state \u00e9 simplesmente a forma como as informa\u00e7\u00f5es do state s\u00e3o obtidas, salvas em um reposit\u00f3rio na mem\u00f3ria e recuperadas desse reposit\u00f3rio, para uso pelos diversos componentes React do aplicativo. Com o objetivo de evitar que cada aplicativo criado efetue esse gerenciamento de uma forma diferente e, tamb\u00e9m, para garantir que se usem as melhores e mais eficientes pr\u00e1ticas, nos aplicativos da BuildBox usamos as bibliotecas react-redux e redux-persist , para realizar o gerenciamento de state nos Clients , tanto web quanto mobile . A biblioteca react-redux \u00e9, basicamente, um recipiente ( store ) para manter todo o state do aplicativo em um reposit\u00f3rio \u00fanico, e que, ao mesmo tempo, define m\u00e9todos padr\u00e3o estritos para salvar e disponibilizar as informa\u00e7\u00f5es no e do store, a partir dos componentes React do aplicativo. A biblioteca redux-persist permite que o store do react-redux seja persistido por um storage engine , como por exemplo, o LocalStorage do navegador ou o AsyncStorage no React-Native , o que possibilita a persist\u00eancia do store, mesmo ap\u00f3s atualiza\u00e7\u00f5es ( refreshes ) do navegador, reinicializa\u00e7\u00e3o do navegador, ou at\u00e9 do dispositivo. Funcionamento do React-Redux O react-redux possui 4 componentes principais: Um store onde ser\u00e3o armazenadas as informa\u00e7\u00f5es do aplicativo, que nos interessa armazenar. Um componente React, chamado Provider que \u00e9 respons\u00e1vel por disponibilizar o store redux a todos os componentes da \u00e1rvore de componentes React.. Ele envolve toda a \u00e1rvore de renderiza\u00e7\u00e3o do React, permitindo que todos os componentes envolvidos tenham acesso ao store A\u00e7\u00f5es para salvar partes espec\u00edficas do state do aplicativo no store . A\u00e7\u00f5es para ler partes espec\u00edficas do state armazenado no store . Vamos explicar como isso deve ser feito na forma padronizada definida para o c\u00f3digo da BuildBox . Passo 1: Copiar o c\u00f3digo do store do Harv O c\u00f3digo \u00e9 90% similar em todos os aplicativos e, assim, sugere-se partir do conte\u00fado da pasta /src/store do projeto Harv e fazer as altera\u00e7\u00f5es indicadas nos passos seguintes. Passo 2: Alterar o arquivo /src/store/index.ts Neste arquivo, criamos o store redux e o store persistente, e os exportamos para uso pelo componente App , explicado na se\u00e7\u00e3o 2.3- Roteamento de p\u00e1ginas do Aplicativo . Na imagem abaixo, vemos o c\u00f3digo de renderiza\u00e7\u00e3o do componente App , onde os objetos store e Persistor , importados do arquivo /src/store/index.ts , s\u00e3o disponibilizados para todos os componentes React da \u00e1rvore de renderiza\u00e7\u00e3o do aplicativo. O arquivo /src/store/index.ts \u00e9 igual em todos os aplicativos, exceto pelo conte\u00fado atribu\u00eddo \u00e0 propriedade whitelist do objeto persistConfig , linha 11 no c\u00f3digo acima. No caso do projeto Harv , usado aqui como modelo, as informa\u00e7\u00f5es salvas s\u00e3o organizadas em dois objetos, um chamado 'user' e outro chamado de 'token' . Esses nomes podem variar de aplicativo para aplicativo e, portanto, devem ser alterados conforme o caso. Estas s\u00e3o as \u00fanicas altera\u00e7\u00f5es a serem feitas neste arquivo. Passo 3: Alterar o arquivo /src/store/ducks/index.ts No caso do projeto modelo, usado aqui, estamos organizamos as informa\u00e7\u00f5es a serem salvas no store em dois objetos, que chamamos de user e token , e, desse modo, as linhas 5,6,9 e 10 do c\u00f3digo acima, refletem essas defini\u00e7\u00f5es. Caso o seu aplicativo, tenha outros nomes escolhidos, fa\u00e7a as altera\u00e7\u00f5es necess\u00e1rias nestas linhas e, basicamente, isso \u00e9 tudo o que precisa ser mudado neste arquivo. Passo 4: Alterar o(s) arquivo(s) onde s\u00e3o definidas as a\u00e7\u00f5es redux O conte\u00fado da pasta /src/store , no caso do nosso projeto modelo, Harv , \u00e9 este No caso de um projeto novo, a pasta /src/ducks e os arquivos de nome index.ts n\u00e3o sofrem altera\u00e7\u00f5es de nome, apenas de conte\u00fado, como vimos acima. Os arquivos /src/store/ducks/token.ts e /src/store/ducks/user.ts devem ser ajustados, no nome e conte\u00fado, em conformidade com os tipos de objetos e informa\u00e7\u00f5es que queremos salvar no store no novo aplicativo. Vamos analisar o arquivo /src/store/ducks/user.ts para deixar claro seu conte\u00fado e o que precisa ser mudado, ou n\u00e3o, em novos casos. Em primeiro lugar As linhas de 11 a 15, do c\u00f3digo acima, definem as a\u00e7\u00f5es ( Actions ) do store que poder\u00e3o ser chamadas pelos componentes React do aplicativo para salvar informa\u00e7\u00f5es do Usu\u00e1rio no store . Neste caso, setUser(...) para salvar as informa\u00e7\u00f5es de um objeto User no store e resetUser para atribuir valores vazios ou default ao store do Usu\u00e1rio. Em segundo lugar As linhas de 20 a 37 definem as informa\u00e7\u00f5es a serem armazenadas no store do Usu\u00e1rio, linhas 20 a 35, e as fun\u00e7\u00f5es que devem ser usadas, no caso set e reset para executar as Actions definidas anteriormente. Em terceiro lugar As linhas de 42 a 48 criam o Reducer do objeto user que ser\u00e1 utilizado pelo arquivo /src/store/ducks/index.ts , visto anteriormente e reproduzido abaixo, novamente. Observe que, na linha 6, quando declaramos import user from './user' estamos, de fato, importando o retorno da fun\u00e7\u00e3o createReducer(...) , executada na linha 42 do arquivo anterior, uma vez que esta \u00e9 declarada como export default . Altera\u00e7\u00f5es a serem feitas no arquivo Considerando o apresentado anteriormente, as altera\u00e7\u00f5es a serem feitas neste arquivo s\u00e3o: Alterar os nomes das a\u00e7\u00f5es e do objeto, 'user' , para os nomes apropriados. Alterar as interfaces utilizadas, na linha 11, e as interfaces correspondentes no arquivo /src/types/action.ts , o qual n\u00e3o havia sido citado ainda neste texto, e \u00e9 apresentado abaixo. Alterar o objeto a ser salvo no store , nas linhas 20 a 35, e os nomes das fun\u00e7\u00f5es handlers, conforme o caso. Alterar os nomes e interfaces utilizados em **createReducer(...), conforme os novos nomes e interfaces em uso.","title":"2.8- Gerenciamento de State"},{"location":"2-Design-Patterns/8-state-management/#28-gerenciamento-de-state","text":"","title":"2.8- Gerenciamento de State"},{"location":"2-Design-Patterns/8-state-management/#o-que-e-gerenciamento-de-state","text":"O State \u00e9 um conjunto de informa\u00e7\u00f5es que s\u00e3o importantes para todo o aplicativo, no frontend ( Client ), e que precisam ser preservadas na mem\u00f3ria desse cliente. Tipicamente, o state \u00e9 constitu\u00eddo por informa\u00e7\u00f5es do usu\u00e1rio logado, tais como, nome, e-mail, avatar, token, etc., mas pode incluir outros tipos de informa\u00e7\u00e3o. O Gerenciamento de state \u00e9 simplesmente a forma como as informa\u00e7\u00f5es do state s\u00e3o obtidas, salvas em um reposit\u00f3rio na mem\u00f3ria e recuperadas desse reposit\u00f3rio, para uso pelos diversos componentes React do aplicativo. Com o objetivo de evitar que cada aplicativo criado efetue esse gerenciamento de uma forma diferente e, tamb\u00e9m, para garantir que se usem as melhores e mais eficientes pr\u00e1ticas, nos aplicativos da BuildBox usamos as bibliotecas react-redux e redux-persist , para realizar o gerenciamento de state nos Clients , tanto web quanto mobile . A biblioteca react-redux \u00e9, basicamente, um recipiente ( store ) para manter todo o state do aplicativo em um reposit\u00f3rio \u00fanico, e que, ao mesmo tempo, define m\u00e9todos padr\u00e3o estritos para salvar e disponibilizar as informa\u00e7\u00f5es no e do store, a partir dos componentes React do aplicativo. A biblioteca redux-persist permite que o store do react-redux seja persistido por um storage engine , como por exemplo, o LocalStorage do navegador ou o AsyncStorage no React-Native , o que possibilita a persist\u00eancia do store, mesmo ap\u00f3s atualiza\u00e7\u00f5es ( refreshes ) do navegador, reinicializa\u00e7\u00e3o do navegador, ou at\u00e9 do dispositivo.","title":"O que \u00e9 Gerenciamento de state ?"},{"location":"2-Design-Patterns/8-state-management/#funcionamento-do-react-redux","text":"O react-redux possui 4 componentes principais: Um store onde ser\u00e3o armazenadas as informa\u00e7\u00f5es do aplicativo, que nos interessa armazenar. Um componente React, chamado Provider que \u00e9 respons\u00e1vel por disponibilizar o store redux a todos os componentes da \u00e1rvore de componentes React.. Ele envolve toda a \u00e1rvore de renderiza\u00e7\u00e3o do React, permitindo que todos os componentes envolvidos tenham acesso ao store A\u00e7\u00f5es para salvar partes espec\u00edficas do state do aplicativo no store . A\u00e7\u00f5es para ler partes espec\u00edficas do state armazenado no store . Vamos explicar como isso deve ser feito na forma padronizada definida para o c\u00f3digo da BuildBox .","title":"Funcionamento do React-Redux"},{"location":"2-Design-Patterns/8-state-management/#passo-1-copiar-o-codigo-do-store-do-harv","text":"O c\u00f3digo \u00e9 90% similar em todos os aplicativos e, assim, sugere-se partir do conte\u00fado da pasta /src/store do projeto Harv e fazer as altera\u00e7\u00f5es indicadas nos passos seguintes.","title":"Passo 1: Copiar o c\u00f3digo do store do Harv"},{"location":"2-Design-Patterns/8-state-management/#passo-2-alterar-o-arquivo-srcstoreindexts","text":"Neste arquivo, criamos o store redux e o store persistente, e os exportamos para uso pelo componente App , explicado na se\u00e7\u00e3o 2.3- Roteamento de p\u00e1ginas do Aplicativo . Na imagem abaixo, vemos o c\u00f3digo de renderiza\u00e7\u00e3o do componente App , onde os objetos store e Persistor , importados do arquivo /src/store/index.ts , s\u00e3o disponibilizados para todos os componentes React da \u00e1rvore de renderiza\u00e7\u00e3o do aplicativo. O arquivo /src/store/index.ts \u00e9 igual em todos os aplicativos, exceto pelo conte\u00fado atribu\u00eddo \u00e0 propriedade whitelist do objeto persistConfig , linha 11 no c\u00f3digo acima. No caso do projeto Harv , usado aqui como modelo, as informa\u00e7\u00f5es salvas s\u00e3o organizadas em dois objetos, um chamado 'user' e outro chamado de 'token' . Esses nomes podem variar de aplicativo para aplicativo e, portanto, devem ser alterados conforme o caso. Estas s\u00e3o as \u00fanicas altera\u00e7\u00f5es a serem feitas neste arquivo.","title":"Passo 2: Alterar o arquivo /src/store/index.ts"},{"location":"2-Design-Patterns/8-state-management/#passo-3-alterar-o-arquivo-srcstoreducksindexts","text":"No caso do projeto modelo, usado aqui, estamos organizamos as informa\u00e7\u00f5es a serem salvas no store em dois objetos, que chamamos de user e token , e, desse modo, as linhas 5,6,9 e 10 do c\u00f3digo acima, refletem essas defini\u00e7\u00f5es. Caso o seu aplicativo, tenha outros nomes escolhidos, fa\u00e7a as altera\u00e7\u00f5es necess\u00e1rias nestas linhas e, basicamente, isso \u00e9 tudo o que precisa ser mudado neste arquivo.","title":"Passo 3: Alterar o arquivo /src/store/ducks/index.ts"},{"location":"2-Design-Patterns/8-state-management/#passo-4-alterar-os-arquivos-onde-sao-definidas-as-acoes-redux","text":"O conte\u00fado da pasta /src/store , no caso do nosso projeto modelo, Harv , \u00e9 este No caso de um projeto novo, a pasta /src/ducks e os arquivos de nome index.ts n\u00e3o sofrem altera\u00e7\u00f5es de nome, apenas de conte\u00fado, como vimos acima. Os arquivos /src/store/ducks/token.ts e /src/store/ducks/user.ts devem ser ajustados, no nome e conte\u00fado, em conformidade com os tipos de objetos e informa\u00e7\u00f5es que queremos salvar no store no novo aplicativo. Vamos analisar o arquivo /src/store/ducks/user.ts para deixar claro seu conte\u00fado e o que precisa ser mudado, ou n\u00e3o, em novos casos.","title":"Passo 4: Alterar o(s) arquivo(s) onde s\u00e3o definidas as a\u00e7\u00f5es redux"},{"location":"2-Design-Patterns/8-state-management/#em-primeiro-lugar","text":"As linhas de 11 a 15, do c\u00f3digo acima, definem as a\u00e7\u00f5es ( Actions ) do store que poder\u00e3o ser chamadas pelos componentes React do aplicativo para salvar informa\u00e7\u00f5es do Usu\u00e1rio no store . Neste caso, setUser(...) para salvar as informa\u00e7\u00f5es de um objeto User no store e resetUser para atribuir valores vazios ou default ao store do Usu\u00e1rio.","title":"Em primeiro lugar"},{"location":"2-Design-Patterns/8-state-management/#em-segundo-lugar","text":"As linhas de 20 a 37 definem as informa\u00e7\u00f5es a serem armazenadas no store do Usu\u00e1rio, linhas 20 a 35, e as fun\u00e7\u00f5es que devem ser usadas, no caso set e reset para executar as Actions definidas anteriormente.","title":"Em segundo lugar"},{"location":"2-Design-Patterns/8-state-management/#em-terceiro-lugar","text":"As linhas de 42 a 48 criam o Reducer do objeto user que ser\u00e1 utilizado pelo arquivo /src/store/ducks/index.ts , visto anteriormente e reproduzido abaixo, novamente. Observe que, na linha 6, quando declaramos import user from './user' estamos, de fato, importando o retorno da fun\u00e7\u00e3o createReducer(...) , executada na linha 42 do arquivo anterior, uma vez que esta \u00e9 declarada como export default .","title":"Em terceiro lugar"},{"location":"2-Design-Patterns/8-state-management/#alteracoes-a-serem-feitas-no-arquivo","text":"Considerando o apresentado anteriormente, as altera\u00e7\u00f5es a serem feitas neste arquivo s\u00e3o: Alterar os nomes das a\u00e7\u00f5es e do objeto, 'user' , para os nomes apropriados. Alterar as interfaces utilizadas, na linha 11, e as interfaces correspondentes no arquivo /src/types/action.ts , o qual n\u00e3o havia sido citado ainda neste texto, e \u00e9 apresentado abaixo. Alterar o objeto a ser salvo no store , nas linhas 20 a 35, e os nomes das fun\u00e7\u00f5es handlers, conforme o caso. Alterar os nomes e interfaces utilizados em **createReducer(...), conforme os novos nomes e interfaces em uso.","title":"Altera\u00e7\u00f5es a serem feitas no arquivo"}]}