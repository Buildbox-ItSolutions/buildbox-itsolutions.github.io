{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Padr\u00f5es de C\u00f3digo Este livro apresenta as regras e padr\u00f5es de codifica\u00e7\u00e3o a serem seguidos pelas equipes BuildBox, que desenvolvem software usando as seguintes tecnologias: React.js React-Native TypeScript JavaScript Node.js Nest.js Estes padr\u00f5es t\u00eam dois objetivos principais: Facilitar o desenvolvimento inicial e manuten\u00e7\u00e3o de c\u00f3digo, reduzindo o tempo e custos Garantir o uso de boas pr\u00e1ticas de forma a melhorar a qualidade Os padr\u00f5es est\u00e3o organizados em 2 \u00e1reas, conforme abaixo Legibilidade (Clean Code) - Tornan o c\u00f3digo autoexplicativo e f\u00e1cil de entender Padr\u00f5es de Design - Possibilitam a atualiza\u00e7\u00e3o e evolu\u00e7\u00e3o do c\u00f3digo","title":"Padr\u00f5es de C\u00f3digo"},{"location":"#padroes-de-codigo","text":"Este livro apresenta as regras e padr\u00f5es de codifica\u00e7\u00e3o a serem seguidos pelas equipes BuildBox, que desenvolvem software usando as seguintes tecnologias: React.js React-Native TypeScript JavaScript Node.js Nest.js Estes padr\u00f5es t\u00eam dois objetivos principais: Facilitar o desenvolvimento inicial e manuten\u00e7\u00e3o de c\u00f3digo, reduzindo o tempo e custos Garantir o uso de boas pr\u00e1ticas de forma a melhorar a qualidade Os padr\u00f5es est\u00e3o organizados em 2 \u00e1reas, conforme abaixo Legibilidade (Clean Code) - Tornan o c\u00f3digo autoexplicativo e f\u00e1cil de entender Padr\u00f5es de Design - Possibilitam a atualiza\u00e7\u00e3o e evolu\u00e7\u00e3o do c\u00f3digo","title":"Padr\u00f5es de C\u00f3digo"},{"location":"1-Clean-Code/1-nomenclature/","text":"1.1- Nomenclatura 1.1.1- Usar as seguintes nota\u00e7\u00f5es de caixa Nomes de vari\u00e1veis, propriedades, fun\u00e7\u00f5es, argumentos de fun\u00e7\u00f5es: Usar camelCase Nomes de Componentes React, classes: Usar PascalCase 1.1.2- Usar nomes descritivos e com significado Vari\u00e1veis, propriedades e argumentos de fun\u00e7\u00f5es Usar substantivos, simples ou compostos // Good \ud83d\ude00 const colors = ['blue', 'green', 'yellow'] const color = { name: 'blue', hex: '#800080' } const numberOfColors = 5 const numberOfSelectedColors = 2 Usar um adjetivo seguido por um substantivo // Good \ud83d\ude00 const targetColor = 'purple' const reservedBook = { title: 'The Sun Also Rises', author: 'Ernest Hemingway' } No caso de vari\u00e1veis boolean , usar perguntas // Good \ud83d\ude00 const isLogged = true const isColorSelected = false const isColorValida = true Nomes ruins // Bad \ud83d\ude15 const TargetColor = \"purple\" const fnd = true const list = [\"blue\", \"green\", \"yellow\"] const obj = { color: \"blue\", hex: \"#800080\" } const num = 5 if (exist) { // ... } Fun\u00e7\u00f5es e m\u00e9todos Usar o verbo que descreve o prop\u00f3sito da fun\u00e7\u00e3o + um objeto direto ou indireto // Good \ud83d\ude00 function parseItemPrice(price: string) {...} function calculateTotalCost() {...} function getDeliveryDate() {...} function getRelativeShippingInfo() {...} function saveUserData() {...} function validateForm() {...} function displayErrorMessage() {...} function deleteElement() {...} function fetchAiAPI() {...} Com TypeScript, alguns casos simples permitem o uso apenas do objeto direto, sem o verbo // Good \ud83d\ude00 function toNumber(number: string) {...} // uma contra\u00e7\u00e3o de stringToNumber() Nomes ruins para fun\u00e7\u00f5es ou m\u00e9todos // Bad \ud83d\ude15 function deliveryDate() {...} // Falta o verbo function func1() {...} // N\u00e3o diz nada function test() {...} // Testa o qu\u00ea? function fetch() {...} // Faz um fetch em qu\u00ea? function process() {...} // N\u00e3o diz nada function run() {...} // Executa o qu\u00ea? Componentes Os nomes dos componentes devem usar a conven\u00e7\u00e3o PascalCase , ou seja todas as palavras iniciam com letra mai\u00fascula. Al\u00e9m disso, embora usemos componentes React funcionais, (fun\u00e7\u00f5es JavaScript, ao inv\u00e9s de classes), devemos usar substantivos ou substantivos compostos, sem uso do verbo, como no caso das fun\u00e7\u00f5es. // Good \ud83d\ude00 function Buttom(...) {...} function RadioCard(...) {...} function MultilinesTextField(...) {...} function CancelOrderModal(...) {...} // 'Cancel' aqui n\u00e3o \u00e9 um verbo e, sim, um adjetivo function SellerDetails(...) {...} function AdminProductsList(...) {...} function SellerCreation(...) {...} function SellerEdition(...) {...} function EmailActivation(...) {...} function ProductsList(...) {...} // Bad \ud83d\ude15 function AdminListProducts(...) {...} // 'List' \u00e9 um verbo ao inv\u00e9s de substantivo function CreateSeller(...) {...} // N\u00e3o deveria usar verbo function EditSeller(...) {...} // N\u00e3o deveria usar verbo function ListProducts(...) {...} // 'List' \u00e9 um verbo aqui 1.1.3- Usar nomes espec\u00edficos, evitando nomes amb\u00edguos no escopo Ser espec\u00edfico o suficiente para identificar o que est\u00e1 sendo referenciado de forma un\u00edvoca, no escopo, e preferencialmente, no projeto. Por exemplo, se o escopo \u00e9 uma fun\u00e7\u00e3o de um componente, e \u00e9 necess\u00e1rio salvar um array de 'Pedidos' (Orders) de um certo 'Vendedor' (Seller), podemos usar uma vari\u00e1vel chamada 'orders' para salvar o array , mesmo que sejam pedidos de um vendedor espec\u00edfico. Entretanto se o escopo desta vari\u00e1vel for o componente e for necess\u00e1rio criar um state para salvar o array de 'Pedidos', ainda de um vendedor espec\u00edfico, um nome melhor para este state seria sellerOrders, uma vez que apenas 'orders' subentende que o array salva todos os pedidos de todos os vendedores. Se a fun\u00e7\u00e3o for 'clean' e, portanto, pequena, esta ambiguidade n\u00e3o ocorrer\u00e1, pois ser\u00e1 evidente que 'orders' se refere a pedidos de um vendedor espec\u00edfico. J\u00e1 em um componente, onde o c\u00f3digo \u00e9 bem mais longo do que em uma fun\u00e7\u00e3o, essa ambiguidade n\u00e3o ser\u00e1 percebida com facilidade, deixando o c\u00f3digo mais obscuro e, por isso, a necessidade de nomear o 'state' de forma mais espec\u00edfica. De modo geral, quanto mais amplo o escopo, mais espec\u00edfico deve ser o nome, para impedir conflitos de entendimento. Assim, se estivermos nomeando uma fun\u00e7\u00e3o ou componente 'extern' que pode ser acessado por todo o programa, devemos tornar o nome espec\u00edfico o suficiente para que n\u00e3o possa ser confundido com algo semelhante no resto do sistema. 1.1.4- Ser consistente no escopo do projeto Deve-se procurar usar os mesmos nomes e verbos para os mesmos tipos de conte\u00fado e/ou a\u00e7\u00f5es, dentro do projeto corrente e, se poss\u00edvel, entre todos os projetos da BuildBox. 1.1.5- Usar aspas simples Usar aspas simples nos literais de strings e nomes de propriedades","title":"1.1- Nomenclatura"},{"location":"1-Clean-Code/1-nomenclature/#11-nomenclatura","text":"","title":"1.1- Nomenclatura"},{"location":"1-Clean-Code/1-nomenclature/#111-usar-as-seguintes-notacoes-de-caixa","text":"Nomes de vari\u00e1veis, propriedades, fun\u00e7\u00f5es, argumentos de fun\u00e7\u00f5es: Usar camelCase Nomes de Componentes React, classes: Usar PascalCase","title":"1.1.1- Usar as seguintes nota\u00e7\u00f5es de caixa"},{"location":"1-Clean-Code/1-nomenclature/#112-usar-nomes-descritivos-e-com-significado","text":"","title":"1.1.2- Usar nomes descritivos e com significado"},{"location":"1-Clean-Code/1-nomenclature/#variaveis-propriedades-e-argumentos-de-funcoes","text":"Usar substantivos, simples ou compostos // Good \ud83d\ude00 const colors = ['blue', 'green', 'yellow'] const color = { name: 'blue', hex: '#800080' } const numberOfColors = 5 const numberOfSelectedColors = 2 Usar um adjetivo seguido por um substantivo // Good \ud83d\ude00 const targetColor = 'purple' const reservedBook = { title: 'The Sun Also Rises', author: 'Ernest Hemingway' } No caso de vari\u00e1veis boolean , usar perguntas // Good \ud83d\ude00 const isLogged = true const isColorSelected = false const isColorValida = true Nomes ruins // Bad \ud83d\ude15 const TargetColor = \"purple\" const fnd = true const list = [\"blue\", \"green\", \"yellow\"] const obj = { color: \"blue\", hex: \"#800080\" } const num = 5 if (exist) { // ... }","title":"Vari\u00e1veis, propriedades e argumentos de fun\u00e7\u00f5es"},{"location":"1-Clean-Code/1-nomenclature/#funcoes-e-metodos","text":"Usar o verbo que descreve o prop\u00f3sito da fun\u00e7\u00e3o + um objeto direto ou indireto // Good \ud83d\ude00 function parseItemPrice(price: string) {...} function calculateTotalCost() {...} function getDeliveryDate() {...} function getRelativeShippingInfo() {...} function saveUserData() {...} function validateForm() {...} function displayErrorMessage() {...} function deleteElement() {...} function fetchAiAPI() {...} Com TypeScript, alguns casos simples permitem o uso apenas do objeto direto, sem o verbo // Good \ud83d\ude00 function toNumber(number: string) {...} // uma contra\u00e7\u00e3o de stringToNumber() Nomes ruins para fun\u00e7\u00f5es ou m\u00e9todos // Bad \ud83d\ude15 function deliveryDate() {...} // Falta o verbo function func1() {...} // N\u00e3o diz nada function test() {...} // Testa o qu\u00ea? function fetch() {...} // Faz um fetch em qu\u00ea? function process() {...} // N\u00e3o diz nada function run() {...} // Executa o qu\u00ea?","title":"Fun\u00e7\u00f5es e m\u00e9todos"},{"location":"1-Clean-Code/1-nomenclature/#componentes","text":"Os nomes dos componentes devem usar a conven\u00e7\u00e3o PascalCase , ou seja todas as palavras iniciam com letra mai\u00fascula. Al\u00e9m disso, embora usemos componentes React funcionais, (fun\u00e7\u00f5es JavaScript, ao inv\u00e9s de classes), devemos usar substantivos ou substantivos compostos, sem uso do verbo, como no caso das fun\u00e7\u00f5es. // Good \ud83d\ude00 function Buttom(...) {...} function RadioCard(...) {...} function MultilinesTextField(...) {...} function CancelOrderModal(...) {...} // 'Cancel' aqui n\u00e3o \u00e9 um verbo e, sim, um adjetivo function SellerDetails(...) {...} function AdminProductsList(...) {...} function SellerCreation(...) {...} function SellerEdition(...) {...} function EmailActivation(...) {...} function ProductsList(...) {...} // Bad \ud83d\ude15 function AdminListProducts(...) {...} // 'List' \u00e9 um verbo ao inv\u00e9s de substantivo function CreateSeller(...) {...} // N\u00e3o deveria usar verbo function EditSeller(...) {...} // N\u00e3o deveria usar verbo function ListProducts(...) {...} // 'List' \u00e9 um verbo aqui","title":"Componentes"},{"location":"1-Clean-Code/1-nomenclature/#113-usar-nomes-especificos-evitando-nomes-ambiguos-no-escopo","text":"Ser espec\u00edfico o suficiente para identificar o que est\u00e1 sendo referenciado de forma un\u00edvoca, no escopo, e preferencialmente, no projeto. Por exemplo, se o escopo \u00e9 uma fun\u00e7\u00e3o de um componente, e \u00e9 necess\u00e1rio salvar um array de 'Pedidos' (Orders) de um certo 'Vendedor' (Seller), podemos usar uma vari\u00e1vel chamada 'orders' para salvar o array , mesmo que sejam pedidos de um vendedor espec\u00edfico. Entretanto se o escopo desta vari\u00e1vel for o componente e for necess\u00e1rio criar um state para salvar o array de 'Pedidos', ainda de um vendedor espec\u00edfico, um nome melhor para este state seria sellerOrders, uma vez que apenas 'orders' subentende que o array salva todos os pedidos de todos os vendedores. Se a fun\u00e7\u00e3o for 'clean' e, portanto, pequena, esta ambiguidade n\u00e3o ocorrer\u00e1, pois ser\u00e1 evidente que 'orders' se refere a pedidos de um vendedor espec\u00edfico. J\u00e1 em um componente, onde o c\u00f3digo \u00e9 bem mais longo do que em uma fun\u00e7\u00e3o, essa ambiguidade n\u00e3o ser\u00e1 percebida com facilidade, deixando o c\u00f3digo mais obscuro e, por isso, a necessidade de nomear o 'state' de forma mais espec\u00edfica. De modo geral, quanto mais amplo o escopo, mais espec\u00edfico deve ser o nome, para impedir conflitos de entendimento. Assim, se estivermos nomeando uma fun\u00e7\u00e3o ou componente 'extern' que pode ser acessado por todo o programa, devemos tornar o nome espec\u00edfico o suficiente para que n\u00e3o possa ser confundido com algo semelhante no resto do sistema.","title":"1.1.3- Usar nomes espec\u00edficos, evitando nomes amb\u00edguos no escopo"},{"location":"1-Clean-Code/1-nomenclature/#114-ser-consistente-no-escopo-do-projeto","text":"Deve-se procurar usar os mesmos nomes e verbos para os mesmos tipos de conte\u00fado e/ou a\u00e7\u00f5es, dentro do projeto corrente e, se poss\u00edvel, entre todos os projetos da BuildBox.","title":"1.1.4- Ser consistente no escopo do projeto"},{"location":"1-Clean-Code/1-nomenclature/#115-usar-aspas-simples","text":"Usar aspas simples nos literais de strings e nomes de propriedades","title":"1.1.5- Usar aspas simples"},{"location":"1-Clean-Code/2-code-format/","text":"1.2- Formata\u00e7\u00e3o do c\u00f3digo 1.2.1- Evitar coment\u00e1rios Os nomes dos componentes, fun\u00e7\u00f5es, objetos, vari\u00e1veis e argumentos devem ser autoexplicativos o suficiente, de modo a tornar os coment\u00e1rios desnecess\u00e1rios. Se os nomes forem autoexplicativos e o c\u00f3digo estiver limpo e leg\u00edvel, a maioria dos coment\u00e1rios se tornar\u00e3o dispens\u00e1veis e redudantes, e sua presen\u00e7a, al\u00e9m de dificultar a leitura do c\u00f3digo, poder\u00e1 levar a erros, no caso de modifica\u00e7\u00f5es no c\u00f3digo sem as correspondentes atualiza\u00e7\u00f5es no coment\u00e1rio original. Entretanto, os seguintes tipos de coment\u00e1rio s\u00e3o necess\u00e1rios: - Avisos de natureza jur\u00eddica - Premissas ou pr\u00e9-condi\u00e7\u00f5es para executar uma fun\u00e7\u00e3o - Explica\u00e7\u00f5es sobre algo impl\u00edcito: por exemplo Regex - TO DOs (Modifica\u00e7\u00f5es futuras no c\u00f3digo) Exemplos de coment\u00e1rios \u00fateis: function processPayment(cardNumber, expDate, cvv, amount) { /* This function processes credit card payments Legal: This code must comply with PCI DSS standards. Preconditions: The transaction amount must be > $0. Limitations: This function only supports Visa and Mastercard payments. */ // Function code goes here ... } function getUserData(userID) { /* This function retrieves user data from a database Preconditions: The user must be authenticated and authorized. The user ID must be a valid string. */ // ... code to retrieve user data goes here ... } // accepts [text]@[text].[text], i.e. it simply requires an \"@\" and a dot const emailRegex = /\\S+@\\S+\\.\\S+/; 1.2.2- Formata\u00e7\u00e3o horizontal M\u00e1ximo de 80 caracteres por linha Usar identa\u00e7\u00e3o para expressar o escopo N\u00e3o usar ponto e v\u00edrgula ao final das declara\u00e7\u00f5es, a menos que necess\u00e1rio... Usar aspas simples nas literais de strings e nomes de propriedades Para garantir as regras acima, usar esta configura\u00e7\u00e3o do VSCode para formata\u00e7\u00e3o horizontal 1.2.3- Formata\u00e7\u00e3o vertical Mantenha conceitos relacionados pr\u00f3ximos Use linhas em branco para separar conceitos n\u00e3o relacionados diretamente As fun\u00e7\u00f5es chamadoras devem estar acima das chamadas, se poss\u00edvel Nos componentes, os grupos de fun\u00e7\u00f5es devem vir na ordem abaixo: states fun\u00e7\u00f5es que tratam eventos da renderiza\u00e7\u00e3o ou s\u00e3o passadas para sub-componentes useEffects (disp\u00f4-los na ordem em que s\u00e3o chamados pela atualiza\u00e7\u00e3o dos states) fun\u00e7\u00f5es que cooperam com a renderiza\u00e7\u00e3o return de renderiza\u00e7\u00e3o ou chamada da View do container","title":"1.2- Formata\u00e7\u00e3o do c\u00f3digo"},{"location":"1-Clean-Code/2-code-format/#12-formatacao-do-codigo","text":"","title":"1.2- Formata\u00e7\u00e3o do c\u00f3digo"},{"location":"1-Clean-Code/2-code-format/#121-evitar-comentarios","text":"Os nomes dos componentes, fun\u00e7\u00f5es, objetos, vari\u00e1veis e argumentos devem ser autoexplicativos o suficiente, de modo a tornar os coment\u00e1rios desnecess\u00e1rios. Se os nomes forem autoexplicativos e o c\u00f3digo estiver limpo e leg\u00edvel, a maioria dos coment\u00e1rios se tornar\u00e3o dispens\u00e1veis e redudantes, e sua presen\u00e7a, al\u00e9m de dificultar a leitura do c\u00f3digo, poder\u00e1 levar a erros, no caso de modifica\u00e7\u00f5es no c\u00f3digo sem as correspondentes atualiza\u00e7\u00f5es no coment\u00e1rio original. Entretanto, os seguintes tipos de coment\u00e1rio s\u00e3o necess\u00e1rios: - Avisos de natureza jur\u00eddica - Premissas ou pr\u00e9-condi\u00e7\u00f5es para executar uma fun\u00e7\u00e3o - Explica\u00e7\u00f5es sobre algo impl\u00edcito: por exemplo Regex - TO DOs (Modifica\u00e7\u00f5es futuras no c\u00f3digo) Exemplos de coment\u00e1rios \u00fateis: function processPayment(cardNumber, expDate, cvv, amount) { /* This function processes credit card payments Legal: This code must comply with PCI DSS standards. Preconditions: The transaction amount must be > $0. Limitations: This function only supports Visa and Mastercard payments. */ // Function code goes here ... } function getUserData(userID) { /* This function retrieves user data from a database Preconditions: The user must be authenticated and authorized. The user ID must be a valid string. */ // ... code to retrieve user data goes here ... } // accepts [text]@[text].[text], i.e. it simply requires an \"@\" and a dot const emailRegex = /\\S+@\\S+\\.\\S+/;","title":"1.2.1- Evitar coment\u00e1rios"},{"location":"1-Clean-Code/2-code-format/#122-formatacao-horizontal","text":"M\u00e1ximo de 80 caracteres por linha Usar identa\u00e7\u00e3o para expressar o escopo N\u00e3o usar ponto e v\u00edrgula ao final das declara\u00e7\u00f5es, a menos que necess\u00e1rio... Usar aspas simples nas literais de strings e nomes de propriedades Para garantir as regras acima, usar esta configura\u00e7\u00e3o do VSCode para formata\u00e7\u00e3o horizontal","title":"1.2.2- Formata\u00e7\u00e3o horizontal"},{"location":"1-Clean-Code/2-code-format/#123-formatacao-vertical","text":"Mantenha conceitos relacionados pr\u00f3ximos Use linhas em branco para separar conceitos n\u00e3o relacionados diretamente As fun\u00e7\u00f5es chamadoras devem estar acima das chamadas, se poss\u00edvel Nos componentes, os grupos de fun\u00e7\u00f5es devem vir na ordem abaixo: states fun\u00e7\u00f5es que tratam eventos da renderiza\u00e7\u00e3o ou s\u00e3o passadas para sub-componentes useEffects (disp\u00f4-los na ordem em que s\u00e3o chamados pela atualiza\u00e7\u00e3o dos states) fun\u00e7\u00f5es que cooperam com a renderiza\u00e7\u00e3o return de renderiza\u00e7\u00e3o ou chamada da View do container","title":"1.2.3- Formata\u00e7\u00e3o vertical"},{"location":"1-Clean-Code/3-flow-control/","text":"1.3- Controle do fluxo 1.3.1- Usar testes positivos 1.3.2- Usar o m\u00ednimo aninhamento poss\u00edvel Usar statements de 'Prote\u00e7\u00e3o', ou evitar o uso de else Usar polimorfismo ou fun\u00e7\u00f5es f\u00e1brica Refactorar estruturas de controle em fun\u00e7\u00f5es separadas 1.3.3- Usar try e catch em lugar de 'if' Quando aplic\u00e1vel, usar tratamento de erros (try catch) em lugar de 'ifs'","title":"1.3- Controle do fluxo"},{"location":"1-Clean-Code/3-flow-control/#13-controle-do-fluxo","text":"","title":"1.3- Controle do fluxo"},{"location":"1-Clean-Code/3-flow-control/#131-usar-testes-positivos","text":"","title":"1.3.1- Usar testes positivos"},{"location":"1-Clean-Code/3-flow-control/#132-usar-o-minimo-aninhamento-possivel","text":"Usar statements de 'Prote\u00e7\u00e3o', ou evitar o uso de else Usar polimorfismo ou fun\u00e7\u00f5es f\u00e1brica Refactorar estruturas de controle em fun\u00e7\u00f5es separadas","title":"1.3.2- Usar o m\u00ednimo aninhamento poss\u00edvel"},{"location":"1-Clean-Code/3-flow-control/#133-usar-try-e-catch-em-lugar-de-if","text":"Quando aplic\u00e1vel, usar tratamento de erros (try catch) em lugar de 'ifs'","title":"1.3.3- Usar try e catch em lugar de 'if'"},{"location":"1-Clean-Code/4-functions/","text":"1.4- Fun\u00e7\u00f5es e m\u00e9todos Limitar o n\u00famero de par\u00e2metros Quanto menos, melhor. Usar objetos ou arrays para agrupar m\u00faltiplos par\u00e2metros em um \u00fanico. As fun\u00e7\u00f5es devem ser pequenas e fazer apenas uma coisa (Single Responsability Principle) O n\u00edvel de abstra\u00e7\u00e3o dentro da fun\u00e7\u00e3o deve ser um n\u00edvel abaixo do n\u00edvel impl\u00edcito no nome da fun\u00e7\u00e3o. Evitar misturar n\u00edveis de abstra\u00e7\u00e3o dentro de fun\u00e7\u00f5es. Qualquer coisa a mais deve ser codificada dentro de outra fun\u00e7\u00e3o que ser\u00e1 chamada pela primeira. Por\u00e9m, evitar refatoramento redundante. Usar o DRY C\u00f3digo repetido deve ser codificado em uma ou v\u00e1rias fun\u00e7\u00f5es. Evitar efeitos colaterais Ou seja, evitar trabalhar com par\u00e2metros de listas ou objetos, copiando-os sempre antes de manipul\u00e1-los.","title":"1.4- Fun\u00e7\u00f5es e m\u00e9todos"},{"location":"1-Clean-Code/4-functions/#14-funcoes-e-metodos","text":"","title":"1.4- Fun\u00e7\u00f5es e m\u00e9todos"},{"location":"1-Clean-Code/4-functions/#limitar-o-numero-de-parametros","text":"Quanto menos, melhor. Usar objetos ou arrays para agrupar m\u00faltiplos par\u00e2metros em um \u00fanico.","title":"Limitar o n\u00famero de par\u00e2metros"},{"location":"1-Clean-Code/4-functions/#as-funcoes-devem-ser-pequenas-e-fazer-apenas-uma-coisa-single-responsability-principle","text":"O n\u00edvel de abstra\u00e7\u00e3o dentro da fun\u00e7\u00e3o deve ser um n\u00edvel abaixo do n\u00edvel impl\u00edcito no nome da fun\u00e7\u00e3o. Evitar misturar n\u00edveis de abstra\u00e7\u00e3o dentro de fun\u00e7\u00f5es. Qualquer coisa a mais deve ser codificada dentro de outra fun\u00e7\u00e3o que ser\u00e1 chamada pela primeira. Por\u00e9m, evitar refatoramento redundante.","title":"As fun\u00e7\u00f5es devem ser pequenas e fazer apenas uma coisa (Single Responsability Principle)"},{"location":"1-Clean-Code/4-functions/#usar-o-dry","text":"C\u00f3digo repetido deve ser codificado em uma ou v\u00e1rias fun\u00e7\u00f5es.","title":"Usar o DRY"},{"location":"1-Clean-Code/4-functions/#evitar-efeitos-colaterais","text":"Ou seja, evitar trabalhar com par\u00e2metros de listas ou objetos, copiando-os sempre antes de manipul\u00e1-los.","title":"Evitar efeitos colaterais"},{"location":"1-Clean-Code/5-vscode-config/","text":"1.5- Configura\u00e7\u00e3o VSCode 1.5.1- Baixar o VSCode 1.5.2- Instalar as seguintes extens\u00f5es no VSCode: Prettier , ESLint e TSLint 1.5.3- Instalar as extens\u00f5es e pacotes globalmente com os comando abaixo: npm install -g tslint npm install -g eslint 1.5.4- Usar a configura\u00e7\u00e3o abaixo como configura\u00e7\u00e3o default do VSCode \"files.eol\": \"\\n\", \"editor.insertSpaces\": false, \"editor.renderWhitespace\": \"all\", \"editor.detectIndentation\": false, \"editor.tabSize\": 4, \"editor.renderControlCharacters\": true, \"editor.tabCompletion\": \"on\", \"editor.formatOnSave\": true, \"eslint.enable\": true, \"prettier.semi\": false, \"prettier.printWidth\": 120, \"prettier.useTabs\": true, \"prettier.tabWidth\": 4, \"prettier.singleQuote\": true, \"prettier.jsxBracketSameLine\": true, \"prettier.eslintIntegration\": true, \"prettier.tslintIntegration\": true 1.5.5- Fonte opcional com Ligadures \"terminal.integrated.fontSize\": 14, \"editor.fontFamily\": \"Fira Code\", \"editor.fontSize\": 16, \"editor.lineHeight\": 24, \"editor.fontLigatures\": true,","title":"1.5- Configura\u00e7\u00e3o VSCode"},{"location":"1-Clean-Code/5-vscode-config/#15-configuracao-vscode","text":"1.5.1- Baixar o VSCode 1.5.2- Instalar as seguintes extens\u00f5es no VSCode: Prettier , ESLint e TSLint 1.5.3- Instalar as extens\u00f5es e pacotes globalmente com os comando abaixo: npm install -g tslint npm install -g eslint 1.5.4- Usar a configura\u00e7\u00e3o abaixo como configura\u00e7\u00e3o default do VSCode \"files.eol\": \"\\n\", \"editor.insertSpaces\": false, \"editor.renderWhitespace\": \"all\", \"editor.detectIndentation\": false, \"editor.tabSize\": 4, \"editor.renderControlCharacters\": true, \"editor.tabCompletion\": \"on\", \"editor.formatOnSave\": true, \"eslint.enable\": true, \"prettier.semi\": false, \"prettier.printWidth\": 120, \"prettier.useTabs\": true, \"prettier.tabWidth\": 4, \"prettier.singleQuote\": true, \"prettier.jsxBracketSameLine\": true, \"prettier.eslintIntegration\": true, \"prettier.tslintIntegration\": true 1.5.5- Fonte opcional com Ligadures \"terminal.integrated.fontSize\": 14, \"editor.fontFamily\": \"Fira Code\", \"editor.fontSize\": 16, \"editor.lineHeight\": 24, \"editor.fontLigatures\": true,","title":"1.5- Configura\u00e7\u00e3o VSCode"},{"location":"2-Design-Patterns/design-patterns/","text":"Padr\u00f5es de Design Os padr\u00f5es descritos aqui n\u00e3o s\u00e3o os 23 Design Patterns tornados 'cl\u00e1ssicos' pelo livro Design Patterns, Elements of Reusable Object Oriented Software , cuja primeira edi\u00e7\u00e3o data de 1994. Caso tenha interesse, existe um site muito did\u00e1tico sobre eles aqui . Neste cap\u00edtulo, descrevemos padr\u00f5es atualmente adotados no c\u00f3digo BuildBox, organizados nas categorias a seguir. Programa - Estrutura de Pastas Programa - Configura\u00e7\u00e3o de Estilos Componentes - Coes\u00e3o Componentes - Polimorfismo Componentes - Lei de Demeter Componentes - Princ\u00edpios SOLID Componentes - Controller/View Componentes - Formul\u00e1rios Hooks - React-Query","title":"Padr\u00f5es de Design"},{"location":"2-Design-Patterns/design-patterns/#padroes-de-design","text":"Os padr\u00f5es descritos aqui n\u00e3o s\u00e3o os 23 Design Patterns tornados 'cl\u00e1ssicos' pelo livro Design Patterns, Elements of Reusable Object Oriented Software , cuja primeira edi\u00e7\u00e3o data de 1994. Caso tenha interesse, existe um site muito did\u00e1tico sobre eles aqui . Neste cap\u00edtulo, descrevemos padr\u00f5es atualmente adotados no c\u00f3digo BuildBox, organizados nas categorias a seguir.","title":"Padr\u00f5es de Design"},{"location":"2-Design-Patterns/design-patterns/#programa-estrutura-de-pastas","text":"","title":"Programa - Estrutura de Pastas"},{"location":"2-Design-Patterns/design-patterns/#programa-configuracao-de-estilos","text":"","title":"Programa - Configura\u00e7\u00e3o de Estilos"},{"location":"2-Design-Patterns/design-patterns/#componentes-coesao","text":"","title":"Componentes - Coes\u00e3o"},{"location":"2-Design-Patterns/design-patterns/#componentes-polimorfismo","text":"","title":"Componentes - Polimorfismo"},{"location":"2-Design-Patterns/design-patterns/#componentes-lei-de-demeter","text":"","title":"Componentes - Lei de Demeter"},{"location":"2-Design-Patterns/design-patterns/#componentes-principios-solid","text":"","title":"Componentes - Princ\u00edpios SOLID"},{"location":"2-Design-Patterns/design-patterns/#componentes-controllerview","text":"","title":"Componentes - Controller/View"},{"location":"2-Design-Patterns/design-patterns/#componentes-formularios","text":"","title":"Componentes - Formul\u00e1rios"},{"location":"2-Design-Patterns/design-patterns/#hooks-react-query","text":"","title":"Hooks - React-Query"}]}