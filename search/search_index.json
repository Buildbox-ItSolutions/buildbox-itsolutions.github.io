{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Padr\u00f5es de C\u00f3digo Objetivo deste Guia Este guia apresenta as regras e padr\u00f5es de codifica\u00e7\u00e3o a serem seguidos pelas equipes BuildBox, que desenvolvem software usando as seguintes tecnologias: React.js React-Native TypeScript JavaScript Node.js Nest.js Estes padr\u00f5es t\u00eam dois objetivos principais: Facilitar o desenvolvimento inicial e manuten\u00e7\u00e3o de c\u00f3digo, reduzindo o tempo e custos Garantir o uso de boas pr\u00e1ticas de forma a melhorar a qualidade Os padr\u00f5es est\u00e3o organizados em 2 \u00e1reas Clean Code e Design Patterns , conforme o \u00edndice abaixo. \u00cdndice de Conte\u00fado 1- Clean Code (Legibilidade) - Tornam o c\u00f3digo autoexplicativo e f\u00e1cil de entender 1.1- Nomenclatura 1.1.1- Usar as seguintes nota\u00e7\u00f5es de caixa 1.1.2- Usar nomes descritivos e com significado Vari\u00e1veis, propriedades e argumentos de fun\u00e7\u00f5es Fun\u00e7\u00f5es e m\u00e9todos Componentes 1.1.3- Usar nomes espec\u00edficos, evitando nomes amb\u00edguos no escopo 1.1.4- Ser consistente no escopo do projeto 1.1.5- Usar aspas simples 1.2- Formata\u00e7\u00e3o do c\u00f3digo 1.2.1- Evitar coment\u00e1rios 1.2.2- Formata\u00e7\u00e3o horizontal 1.2.3- Formata\u00e7\u00e3o vertical 1.3- Controle do fluxo 1.3.1- Preferir cl\u00e1usulas condicionais afirmativas, ao inv\u00e9s de negativas 1.3.2- Usar o m\u00ednimo aninhamento poss\u00edvel Usar cl\u00e1usulas condicionais de 'Prote\u00e7\u00e3o' Refatorar estruturas de controle em fun\u00e7\u00f5es separadas 1.3.3- Substituir declara\u00e7\u00f5es switch/if por literais de objetos 1.3.4- Usar Exceptions para tratar erros 1.4- Fun\u00e7\u00f5es e m\u00e9todos 1.4.1- DRY ( D on't R epeat Y ourselt) 1.4.2- As fun\u00e7\u00f5es devem fazer apenas uma coisa (Single Responsability Principle) 1.4.3- Limitar o n\u00famero de argumentos das fun\u00e7\u00f5es 1.4.4- Usar par\u00e2metros default 1.4.5- Evitar efeitos colaterais das fun\u00e7\u00f5es 1.5- Configura\u00e7\u00e3o VSCode 2- Design Patterns (Padr\u00f5es de Design) - Al\u00e9m de tornarem o c\u00f3digo mais f\u00e1cil de entender, possibilitam a atualiza\u00e7\u00e3o e evolu\u00e7\u00e3o do c\u00f3digo 2.1- Programa - Estrutura de pastas do projeto 2.2- Programa - Configura\u00e7\u00e3o de estilos 2.3- Programa - Roteamento de p\u00e1ginas 2.4- Programa - Menu(s) de navega\u00e7\u00e3o 2.5- Programa - Tratamento de erros 2.6- Programa - Autentica\u00e7\u00e3o 2.7- Acesso a APIs 2.8- Componentes - Coes\u00e3o e Reuso 2.9- Componentes - Princ\u00edpios SOLID 2.10- Componentes - Controller/View 2.11- Componentes - Formul\u00e1rios 2.12- Hooks - React-Query","title":"Padr\u00f5es de C\u00f3digo<br>"},{"location":"#padroes-de-codigo","text":"","title":"Padr\u00f5es de C\u00f3digo"},{"location":"#objetivo-deste-guia","text":"Este guia apresenta as regras e padr\u00f5es de codifica\u00e7\u00e3o a serem seguidos pelas equipes BuildBox, que desenvolvem software usando as seguintes tecnologias: React.js React-Native TypeScript JavaScript Node.js Nest.js Estes padr\u00f5es t\u00eam dois objetivos principais: Facilitar o desenvolvimento inicial e manuten\u00e7\u00e3o de c\u00f3digo, reduzindo o tempo e custos Garantir o uso de boas pr\u00e1ticas de forma a melhorar a qualidade Os padr\u00f5es est\u00e3o organizados em 2 \u00e1reas Clean Code e Design Patterns , conforme o \u00edndice abaixo.","title":"Objetivo deste Guia"},{"location":"#indice-de-conteudo","text":"1- Clean Code (Legibilidade) - Tornam o c\u00f3digo autoexplicativo e f\u00e1cil de entender 1.1- Nomenclatura 1.1.1- Usar as seguintes nota\u00e7\u00f5es de caixa 1.1.2- Usar nomes descritivos e com significado Vari\u00e1veis, propriedades e argumentos de fun\u00e7\u00f5es Fun\u00e7\u00f5es e m\u00e9todos Componentes 1.1.3- Usar nomes espec\u00edficos, evitando nomes amb\u00edguos no escopo 1.1.4- Ser consistente no escopo do projeto 1.1.5- Usar aspas simples 1.2- Formata\u00e7\u00e3o do c\u00f3digo 1.2.1- Evitar coment\u00e1rios 1.2.2- Formata\u00e7\u00e3o horizontal 1.2.3- Formata\u00e7\u00e3o vertical 1.3- Controle do fluxo 1.3.1- Preferir cl\u00e1usulas condicionais afirmativas, ao inv\u00e9s de negativas 1.3.2- Usar o m\u00ednimo aninhamento poss\u00edvel Usar cl\u00e1usulas condicionais de 'Prote\u00e7\u00e3o' Refatorar estruturas de controle em fun\u00e7\u00f5es separadas 1.3.3- Substituir declara\u00e7\u00f5es switch/if por literais de objetos 1.3.4- Usar Exceptions para tratar erros 1.4- Fun\u00e7\u00f5es e m\u00e9todos 1.4.1- DRY ( D on't R epeat Y ourselt) 1.4.2- As fun\u00e7\u00f5es devem fazer apenas uma coisa (Single Responsability Principle) 1.4.3- Limitar o n\u00famero de argumentos das fun\u00e7\u00f5es 1.4.4- Usar par\u00e2metros default 1.4.5- Evitar efeitos colaterais das fun\u00e7\u00f5es 1.5- Configura\u00e7\u00e3o VSCode 2- Design Patterns (Padr\u00f5es de Design) - Al\u00e9m de tornarem o c\u00f3digo mais f\u00e1cil de entender, possibilitam a atualiza\u00e7\u00e3o e evolu\u00e7\u00e3o do c\u00f3digo 2.1- Programa - Estrutura de pastas do projeto 2.2- Programa - Configura\u00e7\u00e3o de estilos 2.3- Programa - Roteamento de p\u00e1ginas 2.4- Programa - Menu(s) de navega\u00e7\u00e3o 2.5- Programa - Tratamento de erros 2.6- Programa - Autentica\u00e7\u00e3o 2.7- Acesso a APIs 2.8- Componentes - Coes\u00e3o e Reuso 2.9- Componentes - Princ\u00edpios SOLID 2.10- Componentes - Controller/View 2.11- Componentes - Formul\u00e1rios 2.12- Hooks - React-Query","title":"\u00cdndice de Conte\u00fado"},{"location":"1-Clean-Code/1-nomenclature/","text":"1.1- Nomenclatura 1.1.1- Usar as seguintes nota\u00e7\u00f5es de caixa {#111} Nomes de vari\u00e1veis, propriedades, fun\u00e7\u00f5es, argumentos de fun\u00e7\u00f5es: Usar camelCase Nomes de Componentes React: Usar PascalCase 1.1.2- Usar nomes descritivos e com significado Usar nomes que descrevem claramente e de forma distinta o conte\u00fado da vari\u00e1vel, sem usar abrevia\u00e7\u00f5es que obrigariam o leitor a procurar o significado; expl\u00edcito \u00e9 melhor do que impl\u00edcito. Por exemplo: // Bad \ud83d\ude15 locations.forEach(l => { // Several lines of code, here // ... dispatch(l) // Trying to remenber what `l` means... }) // Good \ud83d\ude00 locations.forEach(location => { // Several lines of code, here // ... dispatch(location) // No waste of time to remember }) Vari\u00e1veis, propriedades e argumentos de fun\u00e7\u00f5es Usar substantivos, simples ou compostos // Good \ud83d\ude00 const colors = ['blue', 'green', 'yellow'] const color = { name: 'blue', hex: '#800080' } const numberOfColors = 5 const numberOfSelectedColors = 2 Usar um adjetivo seguido por um substantivo // Good \ud83d\ude00 const targetColor = 'purple' const reservedBook = { title: 'The Sun Also Rises', author: 'Ernest Hemingway' } No caso de vari\u00e1veis boolean , usar perguntas // Good \ud83d\ude00 const isLogged = true const isColorSelected = false const isColorValida = true Nomes ruins // Bad \ud83d\ude15 const TargetColor = \"purple\" const fnd = true const list = [\"blue\", \"green\", \"yellow\"] const obj = { color: \"blue\", hex: \"#800080\" } const num = 5 if (exist) { // ... } Fun\u00e7\u00f5es e m\u00e9todos Usar o verbo que descreve o prop\u00f3sito da fun\u00e7\u00e3o + um objeto direto ou indireto // Good \ud83d\ude00 function parseItemPrice(price: string) {...} function calculateTotalCost() {...} function getDeliveryDate() {...} function getRelativeShippingInfo() {...} function saveUserData() {...} function validateForm() {...} function displayErrorMessage() {...} function deleteElement() {...} function fetchAiAPI() {...} Com TypeScript, alguns casos simples permitem o uso apenas do objeto direto, sem o verbo // Good \ud83d\ude00 function toNumber(number: string) {...} // uma contra\u00e7\u00e3o de stringToNumber() Nomes ruins para fun\u00e7\u00f5es ou m\u00e9todos // Bad \ud83d\ude15 function deliveryDate() {...} // Falta o verbo function func1() {...} // N\u00e3o diz nada function test() {...} // Testa o qu\u00ea? function fetch() {...} // Faz um fetch em qu\u00ea? function process() {...} // N\u00e3o diz nada function run() {...} // Executa o qu\u00ea? Componentes Os nomes dos componentes devem usar a conven\u00e7\u00e3o PascalCase , ou seja todas as palavras iniciam com letra mai\u00fascula. Al\u00e9m disso, embora usemos componentes React funcionais, (fun\u00e7\u00f5es JavaScript, ao inv\u00e9s de classes), devemos usar substantivos ou substantivos compostos, sem uso do verbo, como no caso das fun\u00e7\u00f5es. // Good \ud83d\ude00 function Buttom(...) {...} function RadioCard(...) {...} function MultilinesTextField(...) {...} function CancelOrderModal(...) {...} // 'Cancel' aqui n\u00e3o \u00e9 um verbo e, sim, um adjetivo function SellerDetails(...) {...} function AdminProductsList(...) {...} function SellerCreation(...) {...} function SellerEdition(...) {...} function EmailActivation(...) {...} function ProductsList(...) {...} // Bad \ud83d\ude15 function AdminListProducts(...) {...} // 'List' \u00e9 um verbo ao inv\u00e9s de substantivo function CreateSeller(...) {...} // N\u00e3o deveria usar verbo function EditSeller(...) {...} // N\u00e3o deveria usar verbo function ListProducts(...) {...} // 'List' \u00e9 um verbo aqui 1.1.3- Usar nomes espec\u00edficos, evitando nomes amb\u00edguos no escopo Ser espec\u00edfico o suficiente para identificar o que est\u00e1 sendo referenciado de forma un\u00edvoca, no escopo, e preferencialmente, no projeto. Por exemplo, se o escopo \u00e9 uma fun\u00e7\u00e3o de um componente, e \u00e9 necess\u00e1rio salvar um array de 'Pedidos' (Orders) de um certo 'Vendedor' (Seller), podemos usar uma vari\u00e1vel chamada 'orders' para salvar o array , mesmo que sejam pedidos de um vendedor espec\u00edfico. Entretanto se o escopo desta vari\u00e1vel for o componente e for necess\u00e1rio criar um state para salvar o array de 'Pedidos', ainda de um vendedor espec\u00edfico, um nome melhor para este state seria sellerOrders, uma vez que apenas 'orders' subentende que o array salva todos os pedidos de todos os vendedores. Se a fun\u00e7\u00e3o for 'clean' e, portanto, pequena, esta ambiguidade n\u00e3o ocorrer\u00e1, pois ser\u00e1 evidente que 'orders' se refere a pedidos de um vendedor espec\u00edfico. J\u00e1 em um componente, onde o c\u00f3digo \u00e9 bem mais longo do que em uma fun\u00e7\u00e3o, essa ambiguidade n\u00e3o ser\u00e1 percebida com facilidade, deixando o c\u00f3digo mais obscuro e, por isso, a necessidade de nomear o 'state' de forma mais espec\u00edfica. De modo geral, quanto mais amplo o escopo, mais espec\u00edfico deve ser o nome, para impedir conflitos de entendimento. Assim, se estivermos nomeando uma fun\u00e7\u00e3o ou componente 'extern' que pode ser acessado por todo o programa, devemos tornar o nome espec\u00edfico o suficiente para que n\u00e3o possa ser confundido com algo semelhante no resto do sistema. 1.1.4- Ser consistente no escopo do projeto Deve-se procurar usar os mesmos nomes e verbos para os mesmos tipos de conte\u00fado e/ou a\u00e7\u00f5es, dentro do projeto corrente e, se poss\u00edvel, entre todos os projetos da BuildBox. Por exemplo: // Bad \ud83d\ude15 getUserInfo() getClientData() getCustomerRecord() // Good \ud83d\ude00 getClient() 1.1.5- Usar aspas simples Usar aspas simples ('') nos literais de strings e nomes de propriedades, ao inv\u00e9s de aspas duplas (\"\").","title":"1.1- Nomenclatura"},{"location":"1-Clean-Code/1-nomenclature/#11-nomenclatura","text":"","title":"1.1- Nomenclatura"},{"location":"1-Clean-Code/1-nomenclature/#111-usar-as-seguintes-notacoes-de-caixa-111","text":"Nomes de vari\u00e1veis, propriedades, fun\u00e7\u00f5es, argumentos de fun\u00e7\u00f5es: Usar camelCase Nomes de Componentes React: Usar PascalCase","title":"1.1.1- Usar as seguintes nota\u00e7\u00f5es de caixa {#111}"},{"location":"1-Clean-Code/1-nomenclature/#112-usar-nomes-descritivos-e-com-significado","text":"Usar nomes que descrevem claramente e de forma distinta o conte\u00fado da vari\u00e1vel, sem usar abrevia\u00e7\u00f5es que obrigariam o leitor a procurar o significado; expl\u00edcito \u00e9 melhor do que impl\u00edcito. Por exemplo: // Bad \ud83d\ude15 locations.forEach(l => { // Several lines of code, here // ... dispatch(l) // Trying to remenber what `l` means... }) // Good \ud83d\ude00 locations.forEach(location => { // Several lines of code, here // ... dispatch(location) // No waste of time to remember })","title":"1.1.2- Usar nomes descritivos e com significado"},{"location":"1-Clean-Code/1-nomenclature/#variaveis-propriedades-e-argumentos-de-funcoes","text":"Usar substantivos, simples ou compostos // Good \ud83d\ude00 const colors = ['blue', 'green', 'yellow'] const color = { name: 'blue', hex: '#800080' } const numberOfColors = 5 const numberOfSelectedColors = 2 Usar um adjetivo seguido por um substantivo // Good \ud83d\ude00 const targetColor = 'purple' const reservedBook = { title: 'The Sun Also Rises', author: 'Ernest Hemingway' } No caso de vari\u00e1veis boolean , usar perguntas // Good \ud83d\ude00 const isLogged = true const isColorSelected = false const isColorValida = true Nomes ruins // Bad \ud83d\ude15 const TargetColor = \"purple\" const fnd = true const list = [\"blue\", \"green\", \"yellow\"] const obj = { color: \"blue\", hex: \"#800080\" } const num = 5 if (exist) { // ... }","title":"Vari\u00e1veis, propriedades e argumentos de fun\u00e7\u00f5es"},{"location":"1-Clean-Code/1-nomenclature/#funcoes-e-metodos","text":"Usar o verbo que descreve o prop\u00f3sito da fun\u00e7\u00e3o + um objeto direto ou indireto // Good \ud83d\ude00 function parseItemPrice(price: string) {...} function calculateTotalCost() {...} function getDeliveryDate() {...} function getRelativeShippingInfo() {...} function saveUserData() {...} function validateForm() {...} function displayErrorMessage() {...} function deleteElement() {...} function fetchAiAPI() {...} Com TypeScript, alguns casos simples permitem o uso apenas do objeto direto, sem o verbo // Good \ud83d\ude00 function toNumber(number: string) {...} // uma contra\u00e7\u00e3o de stringToNumber() Nomes ruins para fun\u00e7\u00f5es ou m\u00e9todos // Bad \ud83d\ude15 function deliveryDate() {...} // Falta o verbo function func1() {...} // N\u00e3o diz nada function test() {...} // Testa o qu\u00ea? function fetch() {...} // Faz um fetch em qu\u00ea? function process() {...} // N\u00e3o diz nada function run() {...} // Executa o qu\u00ea?","title":"Fun\u00e7\u00f5es e m\u00e9todos"},{"location":"1-Clean-Code/1-nomenclature/#componentes","text":"Os nomes dos componentes devem usar a conven\u00e7\u00e3o PascalCase , ou seja todas as palavras iniciam com letra mai\u00fascula. Al\u00e9m disso, embora usemos componentes React funcionais, (fun\u00e7\u00f5es JavaScript, ao inv\u00e9s de classes), devemos usar substantivos ou substantivos compostos, sem uso do verbo, como no caso das fun\u00e7\u00f5es. // Good \ud83d\ude00 function Buttom(...) {...} function RadioCard(...) {...} function MultilinesTextField(...) {...} function CancelOrderModal(...) {...} // 'Cancel' aqui n\u00e3o \u00e9 um verbo e, sim, um adjetivo function SellerDetails(...) {...} function AdminProductsList(...) {...} function SellerCreation(...) {...} function SellerEdition(...) {...} function EmailActivation(...) {...} function ProductsList(...) {...} // Bad \ud83d\ude15 function AdminListProducts(...) {...} // 'List' \u00e9 um verbo ao inv\u00e9s de substantivo function CreateSeller(...) {...} // N\u00e3o deveria usar verbo function EditSeller(...) {...} // N\u00e3o deveria usar verbo function ListProducts(...) {...} // 'List' \u00e9 um verbo aqui","title":"Componentes"},{"location":"1-Clean-Code/1-nomenclature/#113-usar-nomes-especificos-evitando-nomes-ambiguos-no-escopo","text":"Ser espec\u00edfico o suficiente para identificar o que est\u00e1 sendo referenciado de forma un\u00edvoca, no escopo, e preferencialmente, no projeto. Por exemplo, se o escopo \u00e9 uma fun\u00e7\u00e3o de um componente, e \u00e9 necess\u00e1rio salvar um array de 'Pedidos' (Orders) de um certo 'Vendedor' (Seller), podemos usar uma vari\u00e1vel chamada 'orders' para salvar o array , mesmo que sejam pedidos de um vendedor espec\u00edfico. Entretanto se o escopo desta vari\u00e1vel for o componente e for necess\u00e1rio criar um state para salvar o array de 'Pedidos', ainda de um vendedor espec\u00edfico, um nome melhor para este state seria sellerOrders, uma vez que apenas 'orders' subentende que o array salva todos os pedidos de todos os vendedores. Se a fun\u00e7\u00e3o for 'clean' e, portanto, pequena, esta ambiguidade n\u00e3o ocorrer\u00e1, pois ser\u00e1 evidente que 'orders' se refere a pedidos de um vendedor espec\u00edfico. J\u00e1 em um componente, onde o c\u00f3digo \u00e9 bem mais longo do que em uma fun\u00e7\u00e3o, essa ambiguidade n\u00e3o ser\u00e1 percebida com facilidade, deixando o c\u00f3digo mais obscuro e, por isso, a necessidade de nomear o 'state' de forma mais espec\u00edfica. De modo geral, quanto mais amplo o escopo, mais espec\u00edfico deve ser o nome, para impedir conflitos de entendimento. Assim, se estivermos nomeando uma fun\u00e7\u00e3o ou componente 'extern' que pode ser acessado por todo o programa, devemos tornar o nome espec\u00edfico o suficiente para que n\u00e3o possa ser confundido com algo semelhante no resto do sistema.","title":"1.1.3- Usar nomes espec\u00edficos, evitando nomes amb\u00edguos no escopo"},{"location":"1-Clean-Code/1-nomenclature/#114-ser-consistente-no-escopo-do-projeto","text":"Deve-se procurar usar os mesmos nomes e verbos para os mesmos tipos de conte\u00fado e/ou a\u00e7\u00f5es, dentro do projeto corrente e, se poss\u00edvel, entre todos os projetos da BuildBox. Por exemplo: // Bad \ud83d\ude15 getUserInfo() getClientData() getCustomerRecord() // Good \ud83d\ude00 getClient()","title":"1.1.4- Ser consistente no escopo do projeto"},{"location":"1-Clean-Code/1-nomenclature/#115-usar-aspas-simples","text":"Usar aspas simples ('') nos literais de strings e nomes de propriedades, ao inv\u00e9s de aspas duplas (\"\").","title":"1.1.5- Usar aspas simples"},{"location":"1-Clean-Code/2-code-format/","text":"1.2- Formata\u00e7\u00e3o do c\u00f3digo 1.2.1- Evitar coment\u00e1rios Os nomes dos componentes, fun\u00e7\u00f5es, objetos, vari\u00e1veis e argumentos devem ser autoexplicativos o suficiente, de modo a tornar os coment\u00e1rios desnecess\u00e1rios. Se os nomes forem autoexplicativos e o c\u00f3digo estiver limpo e leg\u00edvel, a maioria dos coment\u00e1rios se tornar\u00e3o dispens\u00e1veis e redudantes, e sua presen\u00e7a, al\u00e9m de dificultar a leitura do c\u00f3digo, poder\u00e1 levar a erros, ao ocorrerem modifica\u00e7\u00f5es no c\u00f3digo, sem a correspondente atualiza\u00e7\u00e3o do coment\u00e1rio original. Entretanto, os seguintes tipos de coment\u00e1rio s\u00e3o \u00fateis e, \u00e0s vezes, necess\u00e1rios: - Avisos de natureza jur\u00eddica - Premissas ou pr\u00e9-condi\u00e7\u00f5es para executar uma fun\u00e7\u00e3o - Explica\u00e7\u00f5es sobre algo impl\u00edcito: por exemplo Regex - TO DOs (Modifica\u00e7\u00f5es futuras no c\u00f3digo) Exemplos de coment\u00e1rios \u00fateis: function processPayment(cardNumber, expDate, cvv, amount) { /* This function processes credit card payments Legal: This code must comply with PCI DSS standards. Preconditions: The transaction amount must be > $0. Limitations: This function only supports Visa and Mastercard payments. */ // Function code goes here ... } function getUserData(userID) { /* This function retrieves user data from a database Preconditions: The user must be authenticated and authorized. The user ID must be a valid string. */ // ... code to retrieve user data goes here ... } // accepts [text]@[text].[text], i.e. it simply requires an \"@\" and a dot const emailRegex = /\\S+@\\S+\\.\\S+/; 1.2.2- Formata\u00e7\u00e3o horizontal M\u00e1ximo de 80 caracteres por linha Usar identa\u00e7\u00e3o para expressar o escopo N\u00e3o usar ponto e v\u00edrgula ao final das declara\u00e7\u00f5es, a menos que necess\u00e1rio... Usar aspas simples nas literais de strings e nomes de propriedades Para garantir as regras acima, usar esta configura\u00e7\u00e3o do VSCode para formata\u00e7\u00e3o horizontal 1.2.3- Formata\u00e7\u00e3o vertical As fun\u00e7\u00f5es chamadoras devem estar acima das fun\u00e7\u00f5es chamadas, sempre que poss\u00edvel. Mantenha conceitos relacionados pr\u00f3ximos, ou seja, idealmente, mantenha as fun\u00e7\u00f5es chamadas imediatamente abaixo de suas fun\u00e7\u00f5es chamadoras. Use linhas em branco para separar conceitos n\u00e3o relacionados diretamente. Nos componentes React, os grupos de elementos devem vir na ordem abaixo: states fun\u00e7\u00f5es que tratam eventos da renderiza\u00e7\u00e3o ou s\u00e3o passadas para sub-componentes useEffects (disp\u00f4-los na ordem em que s\u00e3o chamados pela atualiza\u00e7\u00e3o dos states) fun\u00e7\u00f5es que cooperam com a renderiza\u00e7\u00e3o return de renderiza\u00e7\u00e3o ou chamada da View do container","title":"1.2- Formata\u00e7\u00e3o do c\u00f3digo"},{"location":"1-Clean-Code/2-code-format/#12-formatacao-do-codigo","text":"","title":"1.2- Formata\u00e7\u00e3o do c\u00f3digo"},{"location":"1-Clean-Code/2-code-format/#121-evitar-comentarios","text":"Os nomes dos componentes, fun\u00e7\u00f5es, objetos, vari\u00e1veis e argumentos devem ser autoexplicativos o suficiente, de modo a tornar os coment\u00e1rios desnecess\u00e1rios. Se os nomes forem autoexplicativos e o c\u00f3digo estiver limpo e leg\u00edvel, a maioria dos coment\u00e1rios se tornar\u00e3o dispens\u00e1veis e redudantes, e sua presen\u00e7a, al\u00e9m de dificultar a leitura do c\u00f3digo, poder\u00e1 levar a erros, ao ocorrerem modifica\u00e7\u00f5es no c\u00f3digo, sem a correspondente atualiza\u00e7\u00e3o do coment\u00e1rio original. Entretanto, os seguintes tipos de coment\u00e1rio s\u00e3o \u00fateis e, \u00e0s vezes, necess\u00e1rios: - Avisos de natureza jur\u00eddica - Premissas ou pr\u00e9-condi\u00e7\u00f5es para executar uma fun\u00e7\u00e3o - Explica\u00e7\u00f5es sobre algo impl\u00edcito: por exemplo Regex - TO DOs (Modifica\u00e7\u00f5es futuras no c\u00f3digo) Exemplos de coment\u00e1rios \u00fateis: function processPayment(cardNumber, expDate, cvv, amount) { /* This function processes credit card payments Legal: This code must comply with PCI DSS standards. Preconditions: The transaction amount must be > $0. Limitations: This function only supports Visa and Mastercard payments. */ // Function code goes here ... } function getUserData(userID) { /* This function retrieves user data from a database Preconditions: The user must be authenticated and authorized. The user ID must be a valid string. */ // ... code to retrieve user data goes here ... } // accepts [text]@[text].[text], i.e. it simply requires an \"@\" and a dot const emailRegex = /\\S+@\\S+\\.\\S+/;","title":"1.2.1- Evitar coment\u00e1rios"},{"location":"1-Clean-Code/2-code-format/#122-formatacao-horizontal","text":"M\u00e1ximo de 80 caracteres por linha Usar identa\u00e7\u00e3o para expressar o escopo N\u00e3o usar ponto e v\u00edrgula ao final das declara\u00e7\u00f5es, a menos que necess\u00e1rio... Usar aspas simples nas literais de strings e nomes de propriedades Para garantir as regras acima, usar esta configura\u00e7\u00e3o do VSCode para formata\u00e7\u00e3o horizontal","title":"1.2.2- Formata\u00e7\u00e3o horizontal"},{"location":"1-Clean-Code/2-code-format/#123-formatacao-vertical","text":"As fun\u00e7\u00f5es chamadoras devem estar acima das fun\u00e7\u00f5es chamadas, sempre que poss\u00edvel. Mantenha conceitos relacionados pr\u00f3ximos, ou seja, idealmente, mantenha as fun\u00e7\u00f5es chamadas imediatamente abaixo de suas fun\u00e7\u00f5es chamadoras. Use linhas em branco para separar conceitos n\u00e3o relacionados diretamente. Nos componentes React, os grupos de elementos devem vir na ordem abaixo: states fun\u00e7\u00f5es que tratam eventos da renderiza\u00e7\u00e3o ou s\u00e3o passadas para sub-componentes useEffects (disp\u00f4-los na ordem em que s\u00e3o chamados pela atualiza\u00e7\u00e3o dos states) fun\u00e7\u00f5es que cooperam com a renderiza\u00e7\u00e3o return de renderiza\u00e7\u00e3o ou chamada da View do container","title":"1.2.3- Formata\u00e7\u00e3o vertical"},{"location":"1-Clean-Code/3-flow-control/","text":"1.3- Controle do fluxo 1.3.1- Preferir cl\u00e1usulas condicionais afirmativas, ao inv\u00e9s de negativas Exemplo: // Bad \ud83d\ude15 function isUserNotActive(node) { // ... } if (!isUserNotActive(node)) { // ... } // Good \ud83d\ude00 function isUserActive(node) { // ... } if ( isUserActive(node) ) { // ... } 1.3.2- Usar o m\u00ednimo aninhamento poss\u00edvel Usar cl\u00e1usulas condicionais de 'Prote\u00e7\u00e3o' Uma cl\u00e1usula condicional de prote\u00e7\u00e3o \u00e9 uma declara\u00e7\u00e3o 'if' que faz a fun\u00e7\u00e3o retornar, imediatamente, atrav\u00e9s de um 'return' ou de uma exce\u00e7\u00e3o (Error). Exemplo: // Bad \ud83d\ude15 function getPromotionalPrice(promotionCode) { let price if (promotionCode===PROMOTION_CODE1) { price = getPromotionCode1Price() } else { if (promotionCode===PROMOTION_CODE2) { price = getPromotionCode2Price() } else { if (promotionCode===PROMOTION_STUDENT) { price = getPromotionStudentPrice() } else { price = getDefaultPrice() } } } return price } // Better \ud83d\ude00 function getPromotionalPrice(promotionCode) { if (promotionCode===PROMOTION_CODE1) return getPromotionCode1Price() if (promotionCode===PROMOTION_CODE2) return getPromotionCode2Price() if (promotionCode===PROMOTION_STUDENT) return getPromotionStudentPrice() return getDefaultPrice() } Refatorar estruturas de controle em fun\u00e7\u00f5es separadas Observe o c\u00f3digo abaixo: // Bad \ud83d\ude15 function calculatePayment(age, isStudent, isMember) { let payment = 0 if (age < 18) { if (isStudent) { if (isMember) { if (age < 12) { payment = 5 } else { payment = 10 } } else { payment = 20 } } else { if (isMember) { if (age < 12) { payment = 7 } else { payment = 15 } } else { payment = 25 } } } else { if (isMember) { if (age >= 18 && age < 65) { if (isStudent) { payment = 3 } else { payment = 8 } } else { payment = 10 } } else { if (age >= 18 && age < 65) { if (isStudent) { payment = 5 } else { payment = 15 } } else { payment = 20 } } } return payment } Al\u00e9m de ser uma fun\u00e7\u00e3o muito longa (50 linhas), chega a ter at\u00e9 5 n\u00edveis de aninhamento, o que a torna dif\u00edcil de ler e compreender. Note como a vers\u00e3o desse c\u00f3digo, abaixo, onde v\u00e1rias estruturas de controle foram refatoradas em fun\u00e7\u00f5es, se torna bem mais f\u00e1cil de entender. // Much better! \ud83d\ude00 function calculatePayment(age, isStudent, isMember) { if( isUnderage(age) ) return calculateUnderagePayment(isStudent, isMember, age) if (isAdult(age)) return calculateAdultPayment(isStudent, isMember, age) return calculateSeniorPayment() } function isUnderage(age) { return age < 18 } function isAdult(age) { return age >= 18 && age < 65 } function calculateUnderagePayment(isStudent, isMember, age) { if (isStudent) { return calculateUnderageStudentPayment(isMember, age) } else { return calculateUnderageNonStudentPayment(isMember, age) } } function calculateUnderageStudentPayment(isMember, age) { if (isMember) { return age < 12 ? 5 : 10 } else { return 20 } } function calculateUnderageNonStudentPayment(isMember, age) { if (isMember) { return age < 12 ? 7 : 15 } else { return 25 } } function calculateAdultPayment(isStudent, isMember, age) { if (isMember) { return calculateAdultMemberPayment(isStudent, age) } else { return calculateAdultNonMemberPayment(isStudent, age) } } function calculateAdultMemberPayment(isStudent, age) { return isStudent ? 3 : 8 } function calculateAdultNonMemberPayment(isStudent, age) { return isStudent ? 5 : 15 } function calculateSeniorPayment() { return 20 } Embora o c\u00f3digo final ainda tenha 51 linhas, fica f\u00e1cil de entender o que cada fun\u00e7\u00e3o faz, porque cada grupo de condicionais foi encapsulado em uma fun\u00e7\u00e3o pequena e com um apenas 1 n\u00edvel de aninhamento. 1.3.3- Substituir declara\u00e7\u00f5es switch/if por literais de objetos // Bad \ud83d\ude15 const getServerUrl = (env) => { switch (env) { case \"prod\": return \"prod.myweb.com\" case \"test\": return \"test.myweb.com\" case \"staging\": return \"staging.myweb.com\" default: return \"https://localhost:3000\" } } // Better \ud83d\ude00 const serverUrls = { prod: \"prod.myweb.com\", test: \"test.myweb.com\", staging: \"staging.myweb.com\" } const getServerUrl = (env) => serverUrls[env] || \"https://localhost:3000\" 1.3.4- Usar Exceptions para tratar erros Todos os tipos de erro que impe\u00e7am o fluxo do programa de continuar ou de produzir resultados corretos, devem ser previstos e tratados por meio de excess\u00f5es ( try catch ). A id\u00e9ia b\u00e1sica \u00e9 validar todas as vari\u00e1veis que ser\u00e3o utilizadas em determinado processamento e subir uma excess\u00e3o, caso alguma delas tenha um valor inv\u00e1lido, antes da execu\u00e7\u00e3o do processamento em quest\u00e3o. A se\u00e7\u00e3o Design Patterns / Tratamento de erros detalha a forma padr\u00e3o como isso deve ser feito no c\u00f3digo da BuildBox.","title":"1.3- Controle do fluxo"},{"location":"1-Clean-Code/3-flow-control/#13-controle-do-fluxo","text":"","title":"1.3- Controle do fluxo"},{"location":"1-Clean-Code/3-flow-control/#131-preferir-clausulas-condicionais-afirmativas-ao-inves-de-negativas","text":"Exemplo: // Bad \ud83d\ude15 function isUserNotActive(node) { // ... } if (!isUserNotActive(node)) { // ... } // Good \ud83d\ude00 function isUserActive(node) { // ... } if ( isUserActive(node) ) { // ... }","title":"1.3.1- Preferir cl\u00e1usulas condicionais afirmativas, ao inv\u00e9s de negativas"},{"location":"1-Clean-Code/3-flow-control/#132-usar-o-minimo-aninhamento-possivel","text":"","title":"1.3.2- Usar o m\u00ednimo aninhamento poss\u00edvel"},{"location":"1-Clean-Code/3-flow-control/#usar-clausulas-condicionais-de-protecao","text":"Uma cl\u00e1usula condicional de prote\u00e7\u00e3o \u00e9 uma declara\u00e7\u00e3o 'if' que faz a fun\u00e7\u00e3o retornar, imediatamente, atrav\u00e9s de um 'return' ou de uma exce\u00e7\u00e3o (Error). Exemplo: // Bad \ud83d\ude15 function getPromotionalPrice(promotionCode) { let price if (promotionCode===PROMOTION_CODE1) { price = getPromotionCode1Price() } else { if (promotionCode===PROMOTION_CODE2) { price = getPromotionCode2Price() } else { if (promotionCode===PROMOTION_STUDENT) { price = getPromotionStudentPrice() } else { price = getDefaultPrice() } } } return price } // Better \ud83d\ude00 function getPromotionalPrice(promotionCode) { if (promotionCode===PROMOTION_CODE1) return getPromotionCode1Price() if (promotionCode===PROMOTION_CODE2) return getPromotionCode2Price() if (promotionCode===PROMOTION_STUDENT) return getPromotionStudentPrice() return getDefaultPrice() }","title":"Usar cl\u00e1usulas condicionais de 'Prote\u00e7\u00e3o'"},{"location":"1-Clean-Code/3-flow-control/#refatorar-estruturas-de-controle-em-funcoes-separadas","text":"Observe o c\u00f3digo abaixo: // Bad \ud83d\ude15 function calculatePayment(age, isStudent, isMember) { let payment = 0 if (age < 18) { if (isStudent) { if (isMember) { if (age < 12) { payment = 5 } else { payment = 10 } } else { payment = 20 } } else { if (isMember) { if (age < 12) { payment = 7 } else { payment = 15 } } else { payment = 25 } } } else { if (isMember) { if (age >= 18 && age < 65) { if (isStudent) { payment = 3 } else { payment = 8 } } else { payment = 10 } } else { if (age >= 18 && age < 65) { if (isStudent) { payment = 5 } else { payment = 15 } } else { payment = 20 } } } return payment } Al\u00e9m de ser uma fun\u00e7\u00e3o muito longa (50 linhas), chega a ter at\u00e9 5 n\u00edveis de aninhamento, o que a torna dif\u00edcil de ler e compreender. Note como a vers\u00e3o desse c\u00f3digo, abaixo, onde v\u00e1rias estruturas de controle foram refatoradas em fun\u00e7\u00f5es, se torna bem mais f\u00e1cil de entender. // Much better! \ud83d\ude00 function calculatePayment(age, isStudent, isMember) { if( isUnderage(age) ) return calculateUnderagePayment(isStudent, isMember, age) if (isAdult(age)) return calculateAdultPayment(isStudent, isMember, age) return calculateSeniorPayment() } function isUnderage(age) { return age < 18 } function isAdult(age) { return age >= 18 && age < 65 } function calculateUnderagePayment(isStudent, isMember, age) { if (isStudent) { return calculateUnderageStudentPayment(isMember, age) } else { return calculateUnderageNonStudentPayment(isMember, age) } } function calculateUnderageStudentPayment(isMember, age) { if (isMember) { return age < 12 ? 5 : 10 } else { return 20 } } function calculateUnderageNonStudentPayment(isMember, age) { if (isMember) { return age < 12 ? 7 : 15 } else { return 25 } } function calculateAdultPayment(isStudent, isMember, age) { if (isMember) { return calculateAdultMemberPayment(isStudent, age) } else { return calculateAdultNonMemberPayment(isStudent, age) } } function calculateAdultMemberPayment(isStudent, age) { return isStudent ? 3 : 8 } function calculateAdultNonMemberPayment(isStudent, age) { return isStudent ? 5 : 15 } function calculateSeniorPayment() { return 20 } Embora o c\u00f3digo final ainda tenha 51 linhas, fica f\u00e1cil de entender o que cada fun\u00e7\u00e3o faz, porque cada grupo de condicionais foi encapsulado em uma fun\u00e7\u00e3o pequena e com um apenas 1 n\u00edvel de aninhamento.","title":"Refatorar estruturas de controle em fun\u00e7\u00f5es separadas"},{"location":"1-Clean-Code/3-flow-control/#133-substituir-declaracoes-switchif-por-literais-de-objetos","text":"// Bad \ud83d\ude15 const getServerUrl = (env) => { switch (env) { case \"prod\": return \"prod.myweb.com\" case \"test\": return \"test.myweb.com\" case \"staging\": return \"staging.myweb.com\" default: return \"https://localhost:3000\" } } // Better \ud83d\ude00 const serverUrls = { prod: \"prod.myweb.com\", test: \"test.myweb.com\", staging: \"staging.myweb.com\" } const getServerUrl = (env) => serverUrls[env] || \"https://localhost:3000\"","title":"1.3.3- Substituir declara\u00e7\u00f5es switch/if por literais de objetos"},{"location":"1-Clean-Code/3-flow-control/#134-usar-exceptions-para-tratar-erros","text":"Todos os tipos de erro que impe\u00e7am o fluxo do programa de continuar ou de produzir resultados corretos, devem ser previstos e tratados por meio de excess\u00f5es ( try catch ). A id\u00e9ia b\u00e1sica \u00e9 validar todas as vari\u00e1veis que ser\u00e3o utilizadas em determinado processamento e subir uma excess\u00e3o, caso alguma delas tenha um valor inv\u00e1lido, antes da execu\u00e7\u00e3o do processamento em quest\u00e3o. A se\u00e7\u00e3o Design Patterns / Tratamento de erros detalha a forma padr\u00e3o como isso deve ser feito no c\u00f3digo da BuildBox.","title":"1.3.4- Usar Exceptions para tratar erros"},{"location":"1-Clean-Code/4-functions/","text":"1.4- Fun\u00e7\u00f5es e m\u00e9todos 1.4.1- Usar o DRY ( D on't R epeat Y ourselt) C\u00f3digo que tem o potencial de ser usados em outros lugares do sistema, ou seja, \u00e9 gen\u00e9rico, deve ser escrito (encapsulados) dentro de uma fun\u00e7\u00e3o (que poder\u00e1, por sua vez, chamar outras fun\u00e7\u00f5es). Em outras palavras, n\u00e3o escreva o mesmo c\u00f3digo ou c\u00f3digo muito parecido em mais de um lugar, no sistema. Se ocorrer a necessidade de fazer isso, encapsule tal c\u00f3digo em uma fun\u00e7\u00e3o reus\u00e1vel. Isto facilita o entendimento desse c\u00f3digo por outros desenvolvedores, incluindo voc\u00ea, no futuro, e facilita a manuten\u00e7\u00e3o e expans\u00e3o futuras desse c\u00f3digo. 1.4.2- As fun\u00e7\u00f5es devem fazer apenas uma coisa (Single Responsability Principle) Note que 'fazer apenas uma coisa', aqui, tem um significado especial. Certamente, a maioria das fun\u00e7\u00f5es que criamos faz mais de uma coisa, e tais fun\u00e7\u00f5es n\u00e3o teriam raz\u00e3o de existir n\u00e3o fosse esse fato. Para entendermos o que 'fazer apenas uma coisa' significa, aqui, precisamos explicar um conceito chamado de n\u00edvel de abstra\u00e7\u00e3o . Vamos explicar este conceito com uma ilustra\u00e7\u00e3o concreta. Imagine que voc\u00ea queira realizar uma tarefa de processar um pagamento, que consista na execu\u00e7\u00e3o de 100 passos, em sequ\u00eancia. Como organizaria essa tarefa em JavaScript? Definiria uma \u00fanica fun\u00e7\u00e3o, por exemplo processPayment() , e executaria os 100 passos dentro dessa fun\u00e7\u00e3o? Certamente, essa solu\u00e7\u00e3o n\u00e3o deixaria o c\u00f3digo claro, f\u00e1cil de entender e de manter. Uma solu\u00e7\u00e3o melhor seria: Organizar os 100 passos em 20 grupos de aproximadamente 5 passos, cada. Criar 20 fun\u00e7\u00f5es adicionais, cada uma para executar os passos dentro de cada um desses 20 grupos. Dizemos, ent\u00e3o, que os passos est\u00e3o no n\u00edvel 1 de abstra\u00e7\u00e3o e que as 20 fun\u00e7\u00f5es que executam cada grupo de passos est\u00e3o em um n\u00edvel de abstra\u00e7\u00e3o superior, que chamamos de n\u00edvel 2. Oganizar as 20 fun\u00e7\u00f5es em 4 novos grupos, com 5 fun\u00e7\u00f5es do n\u00edvel 2, em cada um desses 4 grupos. Criar 4 fun\u00e7\u00f5es para executar as fun\u00e7\u00f5es de cada um desses 4 grupos. Agora, podemos dizer que essas 4 novas fun\u00e7\u00f5es est\u00e3o no n\u00edvel 3 de abstra\u00e7\u00e3o. E, por fim, dizemos que o n\u00edvel de abstra\u00e7\u00e3o da fun\u00e7\u00e3o principal, processPayment() , \u00e9 o n\u00edvel 4 de abstra\u00e7\u00e3o. Esta ilustra\u00e7\u00e3o nos permite, ent\u00e3o, explicar que: 'fazer apenas uma coisa' significa fazer apenas uma coisa no n\u00edvel de abstra\u00e7\u00e3o descrito pelo nome da fun\u00e7\u00e3o. E, portanto, o t\u00edtulo desta se\u00e7\u00e3o significa que uma fun\u00e7\u00e3o deve fazer apenas uma coisa no n\u00edvel de abstra\u00e7\u00e3o descrito pelo seu nome . Finalmente, podemos, tamb\u00e9m, estabelecer mais 2 regras que nos ajudam a organizar, de forma clara, o trabalho a ser feito por meio de fun\u00e7\u00f5es: O n\u00edvel de abstra\u00e7\u00e3o do c\u00f3digo, dentro de uma fun\u00e7\u00e3o, deve ser um n\u00edvel abaixo do n\u00edvel impl\u00edcito no nome da fun\u00e7\u00e3o. Deve-se evitar misturar n\u00edveis de abstra\u00e7\u00e3o dentro de fun\u00e7\u00f5es. Ou seja, qualquer coisa que n\u00e3o se encaixe no n\u00edvel abaixo do nome, deve ser codificado em outro lugar. Vamos mostrar um exemplo em c\u00f3digo para ajudar na compreens\u00e3o de tudo o que foi dito. Considere a fun\u00e7\u00e3o renderElement() , abaixo. function renderElement(dataToRender) { const element = dataToRender.element if (element === 'script' || element === 'SCRIPT') { throw new Error('Invalid element.') } let partialOpeningTag = '<' + element const attributes = dataToRender.attributes for (const attribute of attributes) { partialOpeningTag = partialOpeningTag + ' ' + attribute.name + '=\"' + attribute.value + '\"'; } const openingTag = partialOpeningTag + '>' const closingTag = '<!--' + element + '-->' const content = dataToRender.content const template = openingTag + content + closingTag const rootElement = dataToRender.root rootElement.innerHTML = template } Embora o c\u00f3digo acima n\u00e3o seja dif\u00edcil de ler, veja, abaixo, o que acontece quando refactoramos esse c\u00f3digo, utilizando os conceitos desta se\u00e7\u00e3o: function renderElement(dataToRender) { const element = dataToRender.element validateElementType(element) dataToRender.root.innerHTML = buildOpenningTag( element, buildAttributesList(dataToRender.attributes) ) + dataToRender.content + buildClosingTag(element) } function validateElementType(element) { if (element === 'script' || element === 'SCRIPT') { throw new Error('Invalid element.') } } function buildAttributesList(attributes) { let attributeList = '' for (const attribute of attributes) { attributeList = `${attributeList} ${attribute.name}=\"${attribute.value}\"` } return attributeList; } function buildOpenningTag(element, attributes) { return( '<' + element + attributes + '>' ) } function buildClosingTag(element) { return( tag = '<!--' + element + '-->' ) } Observe como o comportamento da fun\u00e7\u00e3o renderElement() , agora, ficou expl\u00edcito, f\u00e1cil de ler e como seu c\u00f3digo foi refatorado em 4 fun\u00e7\u00f5es perfeitamente claras e reus\u00e1veis em outras partes do sistema. Note os n\u00edveis de abstra\u00e7\u00e3o de que falamos anteriormente, no n\u00edvel 1, temos o conte\u00fado das fun\u00e7\u00f5es buildAttributesList() , buildOpenningTag() e buildClosingTag() , no n\u00edvel 2 temos essas tr\u00eas fun\u00e7\u00f5es e no n\u00edvel 3, temos a fun\u00e7\u00e3o renderElement() . Por fim, observe que a atribui\u00e7\u00e3o direta da propriedade dataToRender.root.innerHTML n\u00e3o atende a regra 2, acima, porque essa atribui\u00e7\u00e3o \u00e9 uma a\u00e7\u00e3o que manipula direto o conte\u00fado do DOM e est\u00e1 mais para algo do n\u00edvel 1 do que do n\u00edvel 2. Nesse caso, entretanto, abrimos uma exce\u00e7\u00e3o porque, para resolver isso, ter\u00edamos de criar uma fun\u00e7\u00e3o que receberia o elemento root e o conte\u00fado, como par\u00e2metros, para, depois, apenas fazer a atribui\u00e7\u00e3o da propriedade innerHTML . Ou seja, neste caso, o atendimento da regra 2 acabaria deixando o c\u00f3digo polu\u00eddo e menos claro e, portanto, n\u00e3o vale a pena seguir a regra 2. 1.4.3- Limitar o n\u00famero de argumentos das fun\u00e7\u00f5es Quanto menos argumentos, melhor A partir de 2 argumentos torna-se necess\u00e1rio mapear cada par\u00e2metro, na chamada da fun\u00e7\u00e3o, a cada argumento da declara\u00e7\u00e3o da fun\u00e7\u00e3o. Isto \u00e9 uma informa\u00e7\u00e3o impl\u00edcita que demanda tempo do desenvolvedor. Al\u00e9m disso, o aumento do n\u00famero de par\u00e2metros aumenta exponencialmente o n\u00famero de casos de teste para se testar uma fun\u00e7\u00e3o. Usar objetos ou arrays para agrupar m\u00faltiplos par\u00e2metros em um \u00fanico Caso n\u00e3o seja poss\u00edvel manter apenas 1 ou 2 argumentos, deve-se usar, na chamada da fun\u00e7\u00e3o, um objeto com os mesmos nomes dos argumentos, de modo a tornar expl\u00edcito o que significa cada par\u00e2metro passado, como no exemplo abaixo. // Bad \ud83d\ude15 function compare(first, second, comparator) { if (comparator === 'equal') return first === second if (comparator === 'not equal') return first !== second if (comparator === 'greater') return first > second if (comparator === 'smaller') return first < second } const isSmaller = compare(3, 5, 'smaller') const isEqual = compare(3, 5, 'equal') // Good \ud83d\ude00 function compare(comparisonData) { const { first, second, comparator } = comparisonData if (comparator === 'equal') return first === second if (comparator === 'not equal') return first !== second if (comparator === 'greater') return first > second if (comparator === 'smaller') return first < second } const isSmaller = compare({ first: 3, second: 5, comparator: 'smaller' }) N\u00e3o usar argumentos como flags Flags indicam que a fun\u00e7\u00e3o faz mais de uma coisa e, nesse caso, a fun\u00e7\u00e3o deveria ser dividida em 2 ou mais fun\u00e7\u00f5es. // Bad \ud83d\ude15 function createFile(name, temp) { if (temp) { fs.create(`./temp/${name}`) } else { fs.create(name) } } // Good \ud83d\ude00 function createFile(name) { fs.create(name) } function createTempFile(name) { createFile(`./temp/${name}`) } 1.4.4- Usar par\u00e2metros default Usar argumentos default, quando poss\u00edvel, reduz o n\u00famero de testes condicionais dentro da fun\u00e7\u00e3o. 1.4.5- Evitar efeitos colaterais das fun\u00e7\u00f5es Uma fun\u00e7\u00e3o produz um efeito colateral quando ela envia ou escreve informa\u00e7\u00f5es em qualquer coisa al\u00e9m de receber par\u00e2metros e retornar valores. Um efeito colateral pode ser, por exemplo, escrever em um arquivo, modificar uma vari\u00e1vel global ou modificar um argumento mut\u00e1vel passado como par\u00e2metro, como por exemplo um array ou objeto. Acessar recursos externos \u00e9 necess\u00e1rio, como por exemplo acessar um banco de dados. Nestes casos, o que deve ser feito \u00e9 centralizar onde isso \u00e9 feito em um conjunto de fun\u00e7\u00f5es, componente ou servi\u00e7o designados para tal fim. O acesso ao recurso n\u00e3o deve ser feito de qualquer lugar, sem crit\u00e9rio, e deve sempre passar pelos m\u00e9todos ou fun\u00e7\u00f5es do Componente ou Servi\u00e7o designado para isso. No caso de par\u00e2metros mut\u00e1veis, passados como argumentos para uma fun\u00e7\u00e3o, caso seja necess\u00e1rio transformar esse conte\u00fado passado como par\u00e2metro, o que deve ser feito \u00e9 criar uma c\u00f3pia profunda do objeto em quest\u00e3o, transformar tal objeto e retornar a c\u00f3pia modificada como resultado da fun\u00e7\u00e3o. O resultado de uma fun\u00e7\u00e3o nunca deve ser 'retornado' no objeto passado como par\u00e2metro.","title":"1.4- Fun\u00e7\u00f5es e m\u00e9todos"},{"location":"1-Clean-Code/4-functions/#14-funcoes-e-metodos","text":"","title":"1.4- Fun\u00e7\u00f5es e m\u00e9todos"},{"location":"1-Clean-Code/4-functions/#141-usar-o-dry-dont-repeat-yourselt","text":"C\u00f3digo que tem o potencial de ser usados em outros lugares do sistema, ou seja, \u00e9 gen\u00e9rico, deve ser escrito (encapsulados) dentro de uma fun\u00e7\u00e3o (que poder\u00e1, por sua vez, chamar outras fun\u00e7\u00f5es). Em outras palavras, n\u00e3o escreva o mesmo c\u00f3digo ou c\u00f3digo muito parecido em mais de um lugar, no sistema. Se ocorrer a necessidade de fazer isso, encapsule tal c\u00f3digo em uma fun\u00e7\u00e3o reus\u00e1vel. Isto facilita o entendimento desse c\u00f3digo por outros desenvolvedores, incluindo voc\u00ea, no futuro, e facilita a manuten\u00e7\u00e3o e expans\u00e3o futuras desse c\u00f3digo.","title":"1.4.1- Usar o DRY (Don't Repeat Yourselt)  "},{"location":"1-Clean-Code/4-functions/#142-as-funcoes-devem-fazer-apenas-uma-coisa-single-responsability-principle","text":"Note que 'fazer apenas uma coisa', aqui, tem um significado especial. Certamente, a maioria das fun\u00e7\u00f5es que criamos faz mais de uma coisa, e tais fun\u00e7\u00f5es n\u00e3o teriam raz\u00e3o de existir n\u00e3o fosse esse fato. Para entendermos o que 'fazer apenas uma coisa' significa, aqui, precisamos explicar um conceito chamado de n\u00edvel de abstra\u00e7\u00e3o . Vamos explicar este conceito com uma ilustra\u00e7\u00e3o concreta. Imagine que voc\u00ea queira realizar uma tarefa de processar um pagamento, que consista na execu\u00e7\u00e3o de 100 passos, em sequ\u00eancia. Como organizaria essa tarefa em JavaScript? Definiria uma \u00fanica fun\u00e7\u00e3o, por exemplo processPayment() , e executaria os 100 passos dentro dessa fun\u00e7\u00e3o? Certamente, essa solu\u00e7\u00e3o n\u00e3o deixaria o c\u00f3digo claro, f\u00e1cil de entender e de manter. Uma solu\u00e7\u00e3o melhor seria: Organizar os 100 passos em 20 grupos de aproximadamente 5 passos, cada. Criar 20 fun\u00e7\u00f5es adicionais, cada uma para executar os passos dentro de cada um desses 20 grupos. Dizemos, ent\u00e3o, que os passos est\u00e3o no n\u00edvel 1 de abstra\u00e7\u00e3o e que as 20 fun\u00e7\u00f5es que executam cada grupo de passos est\u00e3o em um n\u00edvel de abstra\u00e7\u00e3o superior, que chamamos de n\u00edvel 2. Oganizar as 20 fun\u00e7\u00f5es em 4 novos grupos, com 5 fun\u00e7\u00f5es do n\u00edvel 2, em cada um desses 4 grupos. Criar 4 fun\u00e7\u00f5es para executar as fun\u00e7\u00f5es de cada um desses 4 grupos. Agora, podemos dizer que essas 4 novas fun\u00e7\u00f5es est\u00e3o no n\u00edvel 3 de abstra\u00e7\u00e3o. E, por fim, dizemos que o n\u00edvel de abstra\u00e7\u00e3o da fun\u00e7\u00e3o principal, processPayment() , \u00e9 o n\u00edvel 4 de abstra\u00e7\u00e3o. Esta ilustra\u00e7\u00e3o nos permite, ent\u00e3o, explicar que: 'fazer apenas uma coisa' significa fazer apenas uma coisa no n\u00edvel de abstra\u00e7\u00e3o descrito pelo nome da fun\u00e7\u00e3o. E, portanto, o t\u00edtulo desta se\u00e7\u00e3o significa que uma fun\u00e7\u00e3o deve fazer apenas uma coisa no n\u00edvel de abstra\u00e7\u00e3o descrito pelo seu nome . Finalmente, podemos, tamb\u00e9m, estabelecer mais 2 regras que nos ajudam a organizar, de forma clara, o trabalho a ser feito por meio de fun\u00e7\u00f5es: O n\u00edvel de abstra\u00e7\u00e3o do c\u00f3digo, dentro de uma fun\u00e7\u00e3o, deve ser um n\u00edvel abaixo do n\u00edvel impl\u00edcito no nome da fun\u00e7\u00e3o. Deve-se evitar misturar n\u00edveis de abstra\u00e7\u00e3o dentro de fun\u00e7\u00f5es. Ou seja, qualquer coisa que n\u00e3o se encaixe no n\u00edvel abaixo do nome, deve ser codificado em outro lugar. Vamos mostrar um exemplo em c\u00f3digo para ajudar na compreens\u00e3o de tudo o que foi dito. Considere a fun\u00e7\u00e3o renderElement() , abaixo. function renderElement(dataToRender) { const element = dataToRender.element if (element === 'script' || element === 'SCRIPT') { throw new Error('Invalid element.') } let partialOpeningTag = '<' + element const attributes = dataToRender.attributes for (const attribute of attributes) { partialOpeningTag = partialOpeningTag + ' ' + attribute.name + '=\"' + attribute.value + '\"'; } const openingTag = partialOpeningTag + '>' const closingTag = '<!--' + element + '-->' const content = dataToRender.content const template = openingTag + content + closingTag const rootElement = dataToRender.root rootElement.innerHTML = template } Embora o c\u00f3digo acima n\u00e3o seja dif\u00edcil de ler, veja, abaixo, o que acontece quando refactoramos esse c\u00f3digo, utilizando os conceitos desta se\u00e7\u00e3o: function renderElement(dataToRender) { const element = dataToRender.element validateElementType(element) dataToRender.root.innerHTML = buildOpenningTag( element, buildAttributesList(dataToRender.attributes) ) + dataToRender.content + buildClosingTag(element) } function validateElementType(element) { if (element === 'script' || element === 'SCRIPT') { throw new Error('Invalid element.') } } function buildAttributesList(attributes) { let attributeList = '' for (const attribute of attributes) { attributeList = `${attributeList} ${attribute.name}=\"${attribute.value}\"` } return attributeList; } function buildOpenningTag(element, attributes) { return( '<' + element + attributes + '>' ) } function buildClosingTag(element) { return( tag = '<!--' + element + '-->' ) } Observe como o comportamento da fun\u00e7\u00e3o renderElement() , agora, ficou expl\u00edcito, f\u00e1cil de ler e como seu c\u00f3digo foi refatorado em 4 fun\u00e7\u00f5es perfeitamente claras e reus\u00e1veis em outras partes do sistema. Note os n\u00edveis de abstra\u00e7\u00e3o de que falamos anteriormente, no n\u00edvel 1, temos o conte\u00fado das fun\u00e7\u00f5es buildAttributesList() , buildOpenningTag() e buildClosingTag() , no n\u00edvel 2 temos essas tr\u00eas fun\u00e7\u00f5es e no n\u00edvel 3, temos a fun\u00e7\u00e3o renderElement() . Por fim, observe que a atribui\u00e7\u00e3o direta da propriedade dataToRender.root.innerHTML n\u00e3o atende a regra 2, acima, porque essa atribui\u00e7\u00e3o \u00e9 uma a\u00e7\u00e3o que manipula direto o conte\u00fado do DOM e est\u00e1 mais para algo do n\u00edvel 1 do que do n\u00edvel 2. Nesse caso, entretanto, abrimos uma exce\u00e7\u00e3o porque, para resolver isso, ter\u00edamos de criar uma fun\u00e7\u00e3o que receberia o elemento root e o conte\u00fado, como par\u00e2metros, para, depois, apenas fazer a atribui\u00e7\u00e3o da propriedade innerHTML . Ou seja, neste caso, o atendimento da regra 2 acabaria deixando o c\u00f3digo polu\u00eddo e menos claro e, portanto, n\u00e3o vale a pena seguir a regra 2.","title":"1.4.2- As fun\u00e7\u00f5es devem fazer apenas uma coisa (Single Responsability Principle)"},{"location":"1-Clean-Code/4-functions/#143-limitar-o-numero-de-argumentos-das-funcoes","text":"Quanto menos argumentos, melhor A partir de 2 argumentos torna-se necess\u00e1rio mapear cada par\u00e2metro, na chamada da fun\u00e7\u00e3o, a cada argumento da declara\u00e7\u00e3o da fun\u00e7\u00e3o. Isto \u00e9 uma informa\u00e7\u00e3o impl\u00edcita que demanda tempo do desenvolvedor. Al\u00e9m disso, o aumento do n\u00famero de par\u00e2metros aumenta exponencialmente o n\u00famero de casos de teste para se testar uma fun\u00e7\u00e3o. Usar objetos ou arrays para agrupar m\u00faltiplos par\u00e2metros em um \u00fanico Caso n\u00e3o seja poss\u00edvel manter apenas 1 ou 2 argumentos, deve-se usar, na chamada da fun\u00e7\u00e3o, um objeto com os mesmos nomes dos argumentos, de modo a tornar expl\u00edcito o que significa cada par\u00e2metro passado, como no exemplo abaixo. // Bad \ud83d\ude15 function compare(first, second, comparator) { if (comparator === 'equal') return first === second if (comparator === 'not equal') return first !== second if (comparator === 'greater') return first > second if (comparator === 'smaller') return first < second } const isSmaller = compare(3, 5, 'smaller') const isEqual = compare(3, 5, 'equal') // Good \ud83d\ude00 function compare(comparisonData) { const { first, second, comparator } = comparisonData if (comparator === 'equal') return first === second if (comparator === 'not equal') return first !== second if (comparator === 'greater') return first > second if (comparator === 'smaller') return first < second } const isSmaller = compare({ first: 3, second: 5, comparator: 'smaller' }) N\u00e3o usar argumentos como flags Flags indicam que a fun\u00e7\u00e3o faz mais de uma coisa e, nesse caso, a fun\u00e7\u00e3o deveria ser dividida em 2 ou mais fun\u00e7\u00f5es. // Bad \ud83d\ude15 function createFile(name, temp) { if (temp) { fs.create(`./temp/${name}`) } else { fs.create(name) } } // Good \ud83d\ude00 function createFile(name) { fs.create(name) } function createTempFile(name) { createFile(`./temp/${name}`) }","title":"1.4.3- Limitar o n\u00famero de argumentos das fun\u00e7\u00f5es"},{"location":"1-Clean-Code/4-functions/#144-usar-parametros-default","text":"Usar argumentos default, quando poss\u00edvel, reduz o n\u00famero de testes condicionais dentro da fun\u00e7\u00e3o.","title":"1.4.4- Usar par\u00e2metros default"},{"location":"1-Clean-Code/4-functions/#145-evitar-efeitos-colaterais-das-funcoes","text":"Uma fun\u00e7\u00e3o produz um efeito colateral quando ela envia ou escreve informa\u00e7\u00f5es em qualquer coisa al\u00e9m de receber par\u00e2metros e retornar valores. Um efeito colateral pode ser, por exemplo, escrever em um arquivo, modificar uma vari\u00e1vel global ou modificar um argumento mut\u00e1vel passado como par\u00e2metro, como por exemplo um array ou objeto. Acessar recursos externos \u00e9 necess\u00e1rio, como por exemplo acessar um banco de dados. Nestes casos, o que deve ser feito \u00e9 centralizar onde isso \u00e9 feito em um conjunto de fun\u00e7\u00f5es, componente ou servi\u00e7o designados para tal fim. O acesso ao recurso n\u00e3o deve ser feito de qualquer lugar, sem crit\u00e9rio, e deve sempre passar pelos m\u00e9todos ou fun\u00e7\u00f5es do Componente ou Servi\u00e7o designado para isso. No caso de par\u00e2metros mut\u00e1veis, passados como argumentos para uma fun\u00e7\u00e3o, caso seja necess\u00e1rio transformar esse conte\u00fado passado como par\u00e2metro, o que deve ser feito \u00e9 criar uma c\u00f3pia profunda do objeto em quest\u00e3o, transformar tal objeto e retornar a c\u00f3pia modificada como resultado da fun\u00e7\u00e3o. O resultado de uma fun\u00e7\u00e3o nunca deve ser 'retornado' no objeto passado como par\u00e2metro.","title":"1.4.5- Evitar efeitos colaterais das fun\u00e7\u00f5es"},{"location":"1-Clean-Code/5-vscode-config/","text":"1.5- Configura\u00e7\u00e3o VSCode 1.5.1- Baixar o VSCode 1.5.2- Instalar as seguintes extens\u00f5es no VSCode: Prettier , ESLint e TSLint 1.5.3- Instalar as extens\u00f5es e pacotes globalmente com os comando abaixo: npm install -g tslint npm install -g eslint 1.5.4- Usar a configura\u00e7\u00e3o abaixo como configura\u00e7\u00e3o default do VSCode \"files.eol\": \"\\n\", \"editor.insertSpaces\": false, \"editor.renderWhitespace\": \"all\", \"editor.detectIndentation\": false, \"editor.tabSize\": 4, \"editor.renderControlCharacters\": true, \"editor.tabCompletion\": \"on\", \"editor.formatOnSave\": true, \"eslint.enable\": true, \"prettier.semi\": false, \"prettier.printWidth\": 120, \"prettier.useTabs\": true, \"prettier.tabWidth\": 4, \"prettier.singleQuote\": true, \"prettier.jsxBracketSameLine\": true, \"prettier.eslintIntegration\": true, \"prettier.tslintIntegration\": true 1.5.5- Fonte opcional com Ligadures \"terminal.integrated.fontSize\": 14, \"editor.fontFamily\": \"Fira Code\", \"editor.fontSize\": 16, \"editor.lineHeight\": 24, \"editor.fontLigatures\": true,","title":"1.5- Configura\u00e7\u00e3o VSCode"},{"location":"1-Clean-Code/5-vscode-config/#15-configuracao-vscode","text":"1.5.1- Baixar o VSCode 1.5.2- Instalar as seguintes extens\u00f5es no VSCode: Prettier , ESLint e TSLint 1.5.3- Instalar as extens\u00f5es e pacotes globalmente com os comando abaixo: npm install -g tslint npm install -g eslint 1.5.4- Usar a configura\u00e7\u00e3o abaixo como configura\u00e7\u00e3o default do VSCode \"files.eol\": \"\\n\", \"editor.insertSpaces\": false, \"editor.renderWhitespace\": \"all\", \"editor.detectIndentation\": false, \"editor.tabSize\": 4, \"editor.renderControlCharacters\": true, \"editor.tabCompletion\": \"on\", \"editor.formatOnSave\": true, \"eslint.enable\": true, \"prettier.semi\": false, \"prettier.printWidth\": 120, \"prettier.useTabs\": true, \"prettier.tabWidth\": 4, \"prettier.singleQuote\": true, \"prettier.jsxBracketSameLine\": true, \"prettier.eslintIntegration\": true, \"prettier.tslintIntegration\": true 1.5.5- Fonte opcional com Ligadures \"terminal.integrated.fontSize\": 14, \"editor.fontFamily\": \"Fira Code\", \"editor.fontSize\": 16, \"editor.lineHeight\": 24, \"editor.fontLigatures\": true,","title":"1.5- Configura\u00e7\u00e3o VSCode"},{"location":"2-Design-Patterns/design-patterns/","text":"Padr\u00f5es de Design Os padr\u00f5es descritos aqui n\u00e3o s\u00e3o os 23 Design Patterns tornados 'cl\u00e1ssicos' pelo livro Design Patterns, Elements of Reusable Object Oriented Software , cuja primeira edi\u00e7\u00e3o data de 1994. Caso tenha interesse, existe um site muito did\u00e1tico sobre eles aqui . Neste cap\u00edtulo, descrevemos padr\u00f5es atualmente adotados no c\u00f3digo BuildBox, organizados nas categorias a seguir. 2.1- Programa - Estrutura de pastas do projeto 2.2- Programa - Configura\u00e7\u00e3o de estilos 2.3- Programa - Roteamento de p\u00e1ginas 2.4- Programa - Menu(s) de navega\u00e7\u00e3o 2.5- Programa - Tratamento de erros 2.6- Programa - Autentica\u00e7\u00e3o 2.7- Acesso a APIs 2.8- Componentes - Coes\u00e3o e Reuso 2.9- Componentes - Princ\u00edpios SOLID 2.10- Componentes - Controller/View 2.11- Componentes - Formul\u00e1rios 2.12- Hooks - React-Query","title":"Padr\u00f5es de Design"},{"location":"2-Design-Patterns/design-patterns/#padroes-de-design","text":"Os padr\u00f5es descritos aqui n\u00e3o s\u00e3o os 23 Design Patterns tornados 'cl\u00e1ssicos' pelo livro Design Patterns, Elements of Reusable Object Oriented Software , cuja primeira edi\u00e7\u00e3o data de 1994. Caso tenha interesse, existe um site muito did\u00e1tico sobre eles aqui . Neste cap\u00edtulo, descrevemos padr\u00f5es atualmente adotados no c\u00f3digo BuildBox, organizados nas categorias a seguir.","title":"Padr\u00f5es de Design"},{"location":"2-Design-Patterns/design-patterns/#21-programa-estrutura-de-pastas-do-projeto","text":"","title":"2.1- Programa - Estrutura de pastas do projeto"},{"location":"2-Design-Patterns/design-patterns/#22-programa-configuracao-de-estilos","text":"","title":"2.2- Programa - Configura\u00e7\u00e3o de estilos"},{"location":"2-Design-Patterns/design-patterns/#23-programa-roteamento-de-paginas","text":"","title":"2.3- Programa - Roteamento de p\u00e1ginas"},{"location":"2-Design-Patterns/design-patterns/#24-programa-menus-de-navegacao","text":"","title":"2.4- Programa - Menu(s) de navega\u00e7\u00e3o"},{"location":"2-Design-Patterns/design-patterns/#25-programa-tratamento-de-erros","text":"","title":"2.5- Programa - Tratamento de erros"},{"location":"2-Design-Patterns/design-patterns/#26-programa-autenticacao","text":"","title":"2.6- Programa - Autentica\u00e7\u00e3o"},{"location":"2-Design-Patterns/design-patterns/#27-acesso-a-apis","text":"","title":"2.7- Acesso a APIs"},{"location":"2-Design-Patterns/design-patterns/#28-componentes-coesao-e-reuso","text":"","title":"2.8- Componentes - Coes\u00e3o e Reuso"},{"location":"2-Design-Patterns/design-patterns/#29-componentes-principios-solid","text":"","title":"2.9- Componentes - Princ\u00edpios SOLID"},{"location":"2-Design-Patterns/design-patterns/#210-componentes-controllerview","text":"","title":"2.10- Componentes - Controller/View"},{"location":"2-Design-Patterns/design-patterns/#211-componentes-formularios","text":"","title":"2.11- Componentes - Formul\u00e1rios"},{"location":"2-Design-Patterns/design-patterns/#212-hooks-react-query","text":"","title":"2.12- Hooks - React-Query"}]}